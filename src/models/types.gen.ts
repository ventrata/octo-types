// This file is auto-generated by @hey-api/openapi-ts

/**
 * The type of discount. Possible values are `NONE`, `FULL`, `SPLIT`, `PRORATED` or `MANUAL`
 */
export enum AdjustmentDiscount {
  NONE = "NONE",
  FULL = "FULL",
  SPLIT = "SPLIT",
  PRORATED = "PRORATED",
  MANUAL = "MANUAL",
}

/**
 * The type of adjustment. Possible values are `BOOKING`, `UNIT` or `PERCENTAGE`
 */
export enum AdjustmentPer {
  BOOKING = "BOOKING",
  UNIT = "UNIT",
  PERCENTAGE = "PERCENTAGE",
}

export type Agent = {
  /**
   * A unique ID / UUID generated to identify the agent.
   */
  id: string;
  /**
   * Agent name.
   */
  name: string;
  /**
   * Agent reference.
   */
  reference: string | null;
  /**
   * An array of tags that can be used to filter.
   */
  tags: Array<string>;
};

export type Availability = {
  /**
   * A unique identifier for this availability. This ID is used during booking and must be unique within the scope of an option.
   */
  id: string;
  /**
   * The start time for this availability in the product’s local time zone. This value must conform to ISO 8601 standards (e.g., "2024-11-17T09:00:00+00:00").
   */
  localDateTimeStart: string;
  /**
   * The end time for this availability in the product’s local time zone. It must also adhere to ISO 8601 standards.
   */
  localDateTimeEnd: string;
  /**
   * The time by which the booking must be confirmed at
   */
  utcCutoffAt: string;
  /**
   * Indicates if this availability spans the entire day. If set to true, there will be no specific start or end times for this availability.
   */
  allDay: boolean;
  /**
   * Indicates if there are remaining slots available for this date or time slot.
   */
  available: boolean;
  /**
   * Defines the current status of the availability:
   * AVAILABLE: Open for booking.
   * FREESALE: Unlimited availability, no capacity limits.
   * SOLD_OUT: No spots available.
   * LIMITED: Less than 50% capacity remaining.
   * CLOSED: The availability is closed.
   */
  status: AvailabilityStatus;
  /**
   * Specifies the number of available slots remaining. Should be nulled or omitted when status is FREESALE. If availability is tracked per unit, this represents the maximum remaining quantity across all units.
   */
  vacancies: number | null;
  /**
   * The total capacity for this availability.
   */
  capacity: number | null;
  /**
   * The maximum number of units that can be sold in a single booking during this availability slot.
   */
  maxUnits: number | null;
  /**
   * Defines the opening hours for this availability, even for start time-based availability. Supports multiple periods for breaks in the day.
   */
  openingHours: Array<OpeningHours>;
  totalCapacity: number | null;
  limitCapacity: number | null;
  limitPaxCount: number;
  noShows: number;
  totalNoShows: number;
  totalPaxCount: number;
  paxCount: number;
  maxPaxCount: number | null;
  /**
   * Whether this availability has pickup available.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupAvailable?: boolean;
  /**
   * Whether pickup is required for this availability.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupRequired?: boolean;
  /**
   * Whether pickup is required for this availability.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupPoints?: Array<PickupPoint>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  unitPricing?: Array<PricingUnit>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Array<Pricing>;
  /**
   * Optional code used to apply a specific offer.
   */
  offerCode?: string | null;
  /**
   * Optional display title of the offer.
   */
  offerTitle?: string | null;
  /**
   * List of available offers for the availability.
   */
  offers?: Array<Offer>;
  /**
   * Best or selected offer for this availability.
   */
  offer?: Offer | null;
  /**
   * Optional text for the meeting point location.
   */
  meetingPoint?: string;
  /**
   * Optional meeting point coordinates as an array [longitude, latitude].
   */
  meetingPointCoordinates?: Array<number>;
  /**
   * Latitude component of the meeting point.
   */
  meetingPointLatitude?: number;
  /**
   * Longitude component of the meeting point.
   */
  meetingPointLongitude?: number;
  /**
   * Local datetime string (ISO 8601) for when to meet.
   */
  meetingLocalDateTime?: string;
  /**
   * Optional reference to the tour group this availability belongs to.
   */
  tourGroup?: TourGroup;
  /**
   * List of important notices related to the availability.
   */
  notices?: Array<Notice>;
};

export type AvailabilityCalendarBody = {
  /**
   * The product id.
   */
  productId: string;
  /**
   * The option id.
   */
  optionId: string;
  /**
   * Start date to query for (YYYY-MM-DD).
   */
  localDateStart?: string;
  /**
   * End date to query for (YYYY-MM-DD).
   */
  localDateEnd?: string;
  units?: Array<AvailabilityUnit>;
  /**
   * Can be used only when pricing capability is used.
   */
  currency?: string;
};

export type AvailabilityCalendarErrorResponse =
  OctoAvailabilityCalendarErrorResponse;

export type AvailabilityCalendarRequest = {
  body: AvailabilityCalendarBody;
};

export type AvailabilityCheckBody = {
  /**
   * The product id.
   */
  productId: string;
  /**
   * The option id.
   */
  optionId: string;
  /**
   * Start date to query for (YYYY-MM-DD). Required if `localDateEnd` is set.
   */
  localDateStart?: string;
  /**
   * End date to query for (YYYY-MM-DD). Required if `localDateStart` is set.
   */
  localDateEnd?: string;
  /**
   * Filter the results by the given ids.
   */
  availabilityIds?: Array<string>;
  units?: Array<AvailabilityUnit>;
  /**
   * Can be used only when pricing capability is used.
   */
  currency?: string;
};

export type AvailabilityCheckErrorResponse = OctoAvailabilityCheckErrorResponse;

export type AvailabilityCheckRequest = {
  body: AvailabilityCheckBody;
};

export type AvailabilityContent = {
  /**
   * Optional text for the meeting point location.
   */
  meetingPoint?: string;
  /**
   * Optional meeting point coordinates as an array [longitude, latitude].
   */
  meetingPointCoordinates?: Array<number>;
  /**
   * Latitude component of the meeting point.
   */
  meetingPointLatitude?: number;
  /**
   * Longitude component of the meeting point.
   */
  meetingPointLongitude?: number;
  /**
   * Local datetime string (ISO 8601) for when to meet.
   */
  meetingLocalDateTime?: string;
  /**
   * Optional reference to the tour group this availability belongs to.
   */
  tourGroup?: TourGroup;
  /**
   * List of important notices related to the availability.
   */
  notices?: Array<Notice>;
};

export type AvailabilityOffers = {
  /**
   * Optional code used to apply a specific offer.
   */
  offerCode?: string | null;
  /**
   * Optional display title of the offer.
   */
  offerTitle?: string | null;
  /**
   * List of available offers for the availability.
   */
  offers?: Array<Offer>;
  /**
   * Best or selected offer for this availability.
   */
  offer?: Offer | null;
};

export type AvailabilityPickups = {
  /**
   * Whether this availability has pickup available.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupAvailable?: boolean;
  /**
   * Whether pickup is required for this availability.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupRequired?: boolean;
  /**
   * Whether pickup is required for this availability.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupPoints?: Array<PickupPoint>;
};

export type AvailabilityPricing = {
  /**
   * Is on the object when Pricing capability is requested.
   */
  unitPricing?: Array<PricingUnit>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Array<Pricing>;
};

export enum AvailabilityStatus {
  AVAILABLE = "AVAILABLE",
  FREESALE = "FREESALE",
  SOLD_OUT = "SOLD_OUT",
  LIMITED = "LIMITED",
  CLOSED = "CLOSED",
}

export enum AvailabilityType {
  START_TIME = "START_TIME",
  OPENING_HOURS = "OPENING_HOURS",
}

export type AvailabilityUnit = {
  /**
   * The unit id.
   */
  id?: string;
  type?: UnitType;
  /**
   * The quantity of the unit.
   */
  quantity: number;
};

export type Booking = {
  /**
   * A unique identifier generated by the supplier system for the booking. This ID ensures traceability and must be unique within the system.
   */
  id: string;
  /**
   * An optional idempotency key set when creating a booking to prevent duplicate bookings in case of retries. Used for API calls.
   */
  uuid: string;
  /**
   * Indicates whether the booking was created in test mode. If true, it is a test booking.
   */
  testMode: boolean;
  /**
   * A reference provided by the reseller to identify the booking.
   */
  resellerReference: string | null;
  /**
   * A reference provided by the reseller to identify the booking.
   */
  supplierReference: string | null;
  /**
   * Represents the current state of the booking:
   * ON_HOLD: Awaiting confirmation.
   * EXPIRED: Not confirmed within the hold expiration time.
   * CONFIRMED: Successfully confirmed.
   * CANCELLED: The booking was canceled.
   * PENDING: Awaiting external confirmation.
   * REDEEMED: The booking has been used.
   */
  status: BookingStatus;
  /**
   * An ISO8601 date time in UTC when the booking was created.
   */
  utcCreatedAt: string;
  /**
   * An ISO8601 date time in UTC when the booking was last updated, if applicable.
   */
  utcUpdatedAt: string;
  /**
   * An ISO8601 date times in UTC for when this booking is due to expire if the status is ON_HOLD.
   */
  utcExpiresAt: string | null;
  /**
   * An ISO8601 date time in UTC at when the booking was redeemed, if applicable.
   */
  utcRedeemedAt: string | null;
  /**
   * An ISO8601 date time in UTC when the booking was confirmed, if applicable.
   */
  utcConfirmedAt: string | null;
  /**
   * The ID of product booked.
   */
  productId: string;
  /**
   * The object of booked product.
   */
  product?: Product;
  /**
   * The ID of option booked.
   */
  optionId: string;
  /**
   * The ID of option booked.
   */
  option?: Option;
  /**
   * The object of booked option.
   */
  cancellable: boolean;
  /**
   * A boolean field indicating whether this booking can be cancelled.
   */
  cancellation: BookingCancellation | null;
  /**
   * Indicates if the booking was made without checking availability.
   */
  freesale: boolean;
  /**
   * The ID of availability booked.
   */
  availabilityId: string | null;
  /**
   * The availability object that was booked.
   */
  availability?: Availability | null;
  /**
   * Customer contact details for the booking (see unit object for per ticket / unit details).
   */
  contact?: CustomerContact;
  /**
   * Customer-facing public notes for the booking.
   */
  notes: string | null;
  /**
   * Specifies all supported methods of how tickets or vouchers for this booking are delivered.
   * TICKET: Delivered individually per unit in the booking, where each person or unit receives a separate ticket. These will be provided in the ticket object.
   * VOUCHER: Delivered as a single voucher for the entire booking, consolidating all units under one document. These will be provided in the voucher object.
   * This field ensures clarity on the format of ticket or voucher delivery to resellers and customers.
   */
  deliveryMethods: Array<DeliveryMethod>;
  /**
   * Details for voucher-based delivery, provided when VOUCHER is one of deliveryMethods.
   */
  voucher: Ticket | null;
  /**
   * An array of unit items included in the booking.
   */
  unitItems: Array<UnitItem>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Pricing;
  /**
   * A UUID you can set when generating the booking to use as an idempotency key.
   */
  rebookingUuid: string | null;
  /**
   * UUID of the original booking if this booking is a rebooking.
   */
  originalRebookingUuid: string | null;
  /**
   * An alias for the booking.
   */
  alias: string | null;
  settlementMethod: SettlementMethod;
  /**
   * If `TRUE`, booking was created as a quote.
   */
  quote: boolean;
  /**
   * Whether the booking can be confirmed.
   */
  confirmable: boolean;
  agent: Agent | null;
  reseller: Reseller | null;
  /**
   * An array of required contact fields.
   */
  requiredContactFields: Array<ContactField>;
  /**
   * An array of visible contact fields.
   */
  visibleContactFields: Array<ContactField>;
  rejection: BookingRejection | null;
  utcNoshowedAt: string | null;
  /**
   * An RFC 3339 date time in UTC when the booking was rebooked.
   */
  utcRebookedAt: string | null;
  tags?: Array<string>;
  user: User | null;
  seller: Seller | null;
  localDateTimeStart: string;
  localDateTimeEnd: string;
  emailReceipt: boolean;
  label: Label | null;
  /**
   * Whether the booking requires a pickup. This field is only present when octo/pickups capability is requested.
   */
  pickupRequested?: boolean;
  /**
   * The pickup ID that identifies the pickup in the booking system to make this reservation. This field is only present when octo/pickups capability is requested.
   */
  pickupId?: string | null;
  /**
   * A hotel name and address that will be included in the booking.
   * This field is only present when octo/pickups capability is requested.
   */
  pickupHotel?: string | null;
  /**
   * A room number in the pickup hotel.
   * This field is only present when octo/pickups capability is requested.
   */
  pickupRoom?: string | null;
  /**
   * Optional notes for the pickup. This field is only present when octo/pickups capability is requested.
   */
  pickupNotes?: string | null;
  /**
   * A pickup point that will be included in the booking. This field is only present when octo/pickups capability is requested.
   */
  pickupPoint?: PickupPoint | null;
  duration?: string;
  durationAmount?: number;
  durationUnit?: DurationUnit;
  meetingLocalDateTime?: string | null;
  meetingPoint?: string | null;
  meetingPointCoordinates?: string | null;
  notices?: Array<Notice>;
  termsAccepted?: boolean;
  primary?: boolean;
  orderId?: string;
  orderReference?: string;
  /**
   * Optional code used to apply a specific offer.
   */
  offerCode?: string | null;
  /**
   * Optional display title of the offer.
   */
  offerTitle?: string | null;
  offerComparisons?: Array<OfferComparison>;
  offerIsCombination?: boolean;
  /**
   * List of available offers for the availability.
   */
  offers?: Array<Offer>;
  /**
   * Best or selected offer for this availability.
   */
  offer?: Offer | null;
  /**
   * An array of questions and andswers that will be included in the booking.
   * This field is only present when octo/questions capability is requested.
   */
  questionAnswers?: Array<QuestionAnswer>;
  /**
   * List of resource allocations associated with the booking.
   */
  resourceAllocations?: Array<ResourceAllocation>;
  giftPayment?: GiftPayment | null;
  extraItems?: Array<ExtraItem>;
  /**
   * Whether the booking is a package.
   * This field is only present when octo/packages capability is requested.
   */
  isPackage?: boolean;
  /**
   * The package ID that identifies the package in the booking system to make this reservation.
   * This field is only present when octo/packages capability is requested.
   */
  packageIncludeId?: string;
  /**
   * A package that will be included in the booking.
   * This field is only present when octo/packages capability is requested.
   */
  packageInclude?: Include | null;
  /**
   * An array of bookings that will be included in the package.
   * This field is only present when octo/packages capability is requested.
   */
  packageBookings?: Array<Booking>;
  /**
   * An array of adjustments that will be included in the booking. This field is only present when octo/adjustments capability is requested.
   */
  adjustments?: Array<BookingAdjustment>;
  identity?: Identity;
  identityId?: string;
};

export type BookingAdjustment = {
  /**
   * The amount of the adjustment.
   */
  per: AdjustmentPer;
  /**
   * The amount of the adjustment.
   */
  amount: number;
  /**
   * Optional notes for the adjustment.
   */
  notes: string | null;
  netDiscount: AdjustmentDiscount;
};

export type BookingAdjustments = {
  /**
   * An array of adjustments that will be included in the booking. This field is only present when octo/adjustments capability is requested.
   */
  adjustments?: Array<BookingAdjustment>;
};

export type BookingCancellation = {
  /**
   * Whether the booking was refunded as part of the cancellation. Possible values are FULL, PARTIAL or NONE
   */
  refund: Refund;
  /**
   * A text value describing why the cancellation happened.
   */
  reason: string | null;
  /**
   * An RFC 3339 date time in UTC indicating when the booking was cancelled.
   */
  utcCancelledAt: string;
};

export type BookingCancellationBody = OctoBookingCancellationBody;

export type BookingCancellationErrorResponse =
  OctoBookingCancellationErrorResponse;

export type BookingCancellationRequest = OctoBookingCancellationRequest & {
  body: BookingCancellationBody;
};

export type BookingCart = {
  primary?: boolean;
  orderId?: string;
  orderReference?: string;
};

export type BookingConfirmationBody = {
  /**
   * Whether you want OCTO Cloud to email the guest a copy of their receipt and tickets. (defaults to false)
   */
  emailReceipt?: boolean;
  /**
   * Your reference for this booking. Also known as a Voucher Number.
   */
  resellerReference?: string;
  /**
   * An array of unit items in the booking. To retain or modify existing unit items, you must include the unit item with the associated uuid, otherwise that unit item will be removed.
   */
  unitItems: Array<UnitItemIdentifier>;
  /**
   * Contact details for the main guest who will attend the tour/attraction. Contact Body can be applied to both the booking object (the main reservation) or the unit object (individual ticket holders - if the supplier requires this information).
   */
  contact: BookingContact;
};

export type BookingConfirmationErrorResponse =
  OctoBookingConfirmationErrorResponse;

export type BookingContact = {
  /**
   * The full name of the booking holder or the ticket holder. Can also be retrieved as an alias for the concatenation of `firstName` and `lastName`
   */
  fullName?: string;
  /**
   * The first name of the booking holder or the ticket holder.
   */
  firstName?: string;
  /**
   * The last name of the booking holder or the ticket holder.
   */
  lastName?: string;
  /**
   * The email address of the booking holder or the ticket holder.
   */
  emailAddress?: string;
  /**
   * The phone number of the booking holder or the ticket holder.
   */
  phoneNumber?: string;
  /**
   * An array of locale values, equivalent to navigator.languages in a browsers environment.
   */
  locales?: Array<string>;
  /**
   * The PO Box of the booking holder or the ticket holder.
   */
  postalCode?: string;
  /**
   * The country of the booking holder or the ticket holder.
   */
  country?: string;
  /**
   * Optional notes for the booking.
   */
  notes?: string;
  /**
   * The tax ID of the booking holder or the ticket holder.
   */
  taxId?: string | null;
  /**
   * The street address of the booking holder or the ticket holder.
   */
  streetAddress?: string | null;
  /**
   * The city of the booking holder or the ticket holder.
   */
  city?: string | null;
  /**
   * The state of the booking holder or the ticket holder.
   */
  state?: string | null;
  /**
   * Whether the booking holder or the ticket holder allows marketing.
   */
  allowMarketing?: boolean;
};

export type BookingContent = {
  duration?: string;
  durationAmount?: number;
  durationUnit?: DurationUnit;
  meetingLocalDateTime?: string | null;
  meetingPoint?: string | null;
  meetingPointCoordinates?: string | null;
  notices?: Array<Notice>;
  termsAccepted?: boolean;
};

export type BookingExtras = {
  extraItems?: Array<ExtraItem>;
};

export type BookingGifts = {
  giftPayment?: GiftPayment | null;
};

export type BookingIdentities = {
  identity?: Identity;
  identityId?: string;
};

export type BookingOffers = {
  /**
   * Optional code used to apply a specific offer.
   */
  offerCode?: string | null;
  /**
   * Optional display title of the offer.
   */
  offerTitle?: string | null;
  offerComparisons?: Array<OfferComparison>;
  offerIsCombination?: boolean;
  /**
   * List of available offers for the availability.
   */
  offers?: Array<Offer>;
  /**
   * Best or selected offer for this availability.
   */
  offer?: Offer | null;
};

export type BookingPackages = {
  /**
   * Whether the booking is a package.
   * This field is only present when octo/packages capability is requested.
   */
  isPackage?: boolean;
  /**
   * The package ID that identifies the package in the booking system to make this reservation.
   * This field is only present when octo/packages capability is requested.
   */
  packageIncludeId?: string;
  /**
   * A package that will be included in the booking.
   * This field is only present when octo/packages capability is requested.
   */
  packageInclude?: Include | null;
  /**
   * An array of bookings that will be included in the package.
   * This field is only present when octo/packages capability is requested.
   */
  packageBookings?: Array<Booking>;
};

export type BookingPickups = {
  /**
   * Whether the booking requires a pickup. This field is only present when octo/pickups capability is requested.
   */
  pickupRequested?: boolean;
  /**
   * The pickup ID that identifies the pickup in the booking system to make this reservation. This field is only present when octo/pickups capability is requested.
   */
  pickupId?: string | null;
  /**
   * A hotel name and address that will be included in the booking.
   * This field is only present when octo/pickups capability is requested.
   */
  pickupHotel?: string | null;
  /**
   * A room number in the pickup hotel.
   * This field is only present when octo/pickups capability is requested.
   */
  pickupRoom?: string | null;
  /**
   * Optional notes for the pickup. This field is only present when octo/pickups capability is requested.
   */
  pickupNotes?: string | null;
  /**
   * A pickup point that will be included in the booking. This field is only present when octo/pickups capability is requested.
   */
  pickupPoint?: PickupPoint | null;
};

export type BookingPricing = {
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Pricing;
};

export type BookingQuestions = {
  /**
   * An array of questions and andswers that will be included in the booking.
   * This field is only present when octo/questions capability is requested.
   */
  questionAnswers?: Array<QuestionAnswer>;
};

export type BookingRejection = {
  /**
   * A text value describing why the rejection happened.
   */
  reason: string | null;
  /**
   * An RFC 3339 date time in UTC indicating when the booking was rejected.
   */
  utcRejectedAt: string | null;
};

export type BookingReservationBody = {
  /**
   * Your reference for this booking. Also known as a Voucher Number.
   */
  resellerReference?: string;
  /**
   * The product ID.
   */
  productId: string;
  /**
   * The option id.
   */
  optionId: string;
  /**
   * The availability ID for the selected timeslot.
   */
  availabilityId?: string;
  /**
   * How many minutes to reserve the availability, otherwise defaults to the supplier default amount.
   */
  expirationMinutes?: number;
  /**
   * Optional notes for the booking.
   */
  notes?: string;
  /**
   * Whether you want OCTO Cloud to email the guest a copy of their receipt and tickets. (defaults to false).
   */
  emailReceipt?: boolean;
  /**
   * An array of unit items in the booking. To retain or modify existing unit items, you must include the unit item with the associated uuid, otherwise that unit item will be removed.
   */
  unitItems: Array<UnitItemIdentifier>;
  /**
   * Contact details for the main guest who will attend the tour/attraction. Contact BODY can be applied to both the booking object (the main reservation) or the unit object (individual ticket holders - if the supplier requires this information).
   */
  contact?: BookingContact;
  /**
   * Can be used only when pricing capability is used.
   */
  currency?: string;
  /**
   * The alias of the unit item.
   */
  alias?: string;
  settlementMethod?: SettlementMethod;
  /**
   * Whether to quote the booking instead of confirming it.
   */
  quote?: boolean;
  /**
   * Whether to set freesale mode.
   */
  freesale?: boolean;
  /**
   * Whether the booking was redeemed.
   */
  redeemed?: boolean;
  /**
   * A unique UUID to identify the booking. Setting this value acts like an idempotency key preventing you from double booking.
   */
  uuid?: string;
  tags?: Array<string>;
  orderId?: string;
};

export type BookingReservationErrorResponse =
  OctoBookingReservationErrorResponse;

export type BookingReservationRequest = {
  body: BookingReservationBody;
};

export type BookingResources = {
  /**
   * List of resource allocations associated with the booking.
   */
  resourceAllocations?: Array<ResourceAllocation>;
};

export enum BookingStatus {
  ON_HOLD = "ON_HOLD",
  CONFIRMED = "CONFIRMED",
  EXPIRED = "EXPIRED",
  CANCELLED = "CANCELLED",
  REDEEMED = "REDEEMED",
  PENDING = "PENDING",
  REJECTED = "REJECTED",
  NOSHOW = "NOSHOW",
  UPGRADED = "UPGRADED",
}

export type BookingUpdateBody = {
  /**
   * Your reference for this booking. Also known as a Voucher Number.
   */
  resellerReference?: string;
  /**
   * The product ID.
   */
  productId?: string;
  /**
   * The option id.
   */
  optionId?: string;
  /**
   * The availability ID for the selected timeslot.
   */
  availabilityId?: string;
  /**
   * How many minutes to reserve the availability, otherwise defaults to the supplier default amount.
   */
  expirationMinutes?: number;
  /**
   * Optional notes for the booking.
   */
  notes?: string;
  /**
   * Whether you want OCTO Cloud to email the guest a copy of their receipt and tickets. (defaults to false).
   */
  emailReceipt?: boolean;
  /**
   * An array of unit items in the booking. To retain or modify existing unit items, you must include the unit item with the associated uuid, otherwise that unit item will be removed.
   */
  unitItems?: Array<UnitItemIdentifier>;
  /**
   * Contact details for the main guest who will attend the tour/attraction. Contact BODY can be applied to both the booking object (the main reservation) or the unit object (individual ticket holders - if the supplier requires this information).
   */
  contact?: BookingContact;
  /**
   * The alias of the unit item.
   */
  alias?: string;
  settlementMethod?: SettlementMethod;
  /**
   * Whether to quote the booking instead of confirming it.
   */
  quote?: boolean;
  /**
   * Whether to set freesale mode.
   */
  freesale?: boolean;
  /**
   * Whether the booking was redeemed.
   */
  redeemed?: boolean;
  /**
   * A unique UUID to identify the booking. Setting this value acts like an idempotency key preventing you from double booking.
   */
  uuid?: string;
  tags?: Array<string>;
};

export type BookingUpdateRequest = {
  body: BookingUpdateBody;
};

export type Brand = {
  id: string | null;
  name: string | null;
  contact: BrandContact | null;
  color: string | null;
  secondaryColor: string | null;
  backgroundColor: string | null;
  accentFont: Font | null;
  bodyFont: Font | null;
  headerFont: Font | null;
  checkoutLogoUrl: string | null;
  logoUrl: string | null;
  logoWhiteUrl: string | null;
  faviconUrl: string | null;
};

export type BrandContact = {
  name: string | null;
  email: string | null;
  telephone: string | null;
  address: string | null;
  website: string | null;
};

export enum CancellationCutoffUnit {
  HOUR = "hour",
  MINUTE = "minute",
  DAY = "day",
}

export enum Capability {
  OCTO_CONTENT = "octo/content",
  OCTO_PRICING = "octo/pricing",
  OCTO_PICKUPS = "octo/pickups",
  OCTO_ADJUSTMENTS = "octo/adjustments",
  OCTO_OFFERS = "octo/offers",
  OCTO_CART = "octo/cart",
  OCTO_CARD_PAYMENTS = "octo/cardPayments",
  OCTO_CHECKIN = "octo/checkin",
  OCTO_WEBHOOKS = "octo/webhooks",
  OCTO_MAPPINGS = "octo/mappings",
  OCTO_REDEMPTION = "octo/redemption",
  OCTO_GOOGLE = "octo/google",
  OCTO_QUESTIONS = "octo/questions",
  OCTO_RESOURCES = "octo/resources",
  OCTO_GIFTS = "octo/gifts",
  OCTO_EXTRAS = "octo/extras",
  OCTO_PACKAGES = "octo/packages",
  OCTO_IDENTITIES = "octo/identities",
  VENTRATA_CONTENT = "ventrata/content",
  VENTRATA_GETYOURGUIDE = "ventrata/getyourguide",
  VENTRATA_PARTNERS = "ventrata/partners",
}

export type Category = {
  /**
   * Unique identifier used in the platform to represent the category.
   */
  id: string;
  /**
   * TRUE` identifies the category as default, and should therefore rendered and selected first
   */
  default: boolean;
  /**
   * The name of the category.
   */
  name: string | null;
  /**
   * The title of the category.
   */
  title: string | null;
  /**
   * An array of tags that the category falls under.
   */
  tags: Array<string>;
  /**
   * The description of the category
   */
  shortDescription: string | null;
  /**
   * The URL of the image that represents the category.
   */
  coverImageUrl: string | null;
  /**
   * The URL of the image that represents the category.
   */
  bannerImageUrl: string | null;
  /**
   * An array of product IDs that the category falls under. This field is not visible if this Category is a product category.
   */
  productIds: Array<string>;
};

export enum ContactField {
  FIRST_NAME = "firstName",
  LAST_NAME = "lastName",
  EMAIL_ADDRESS = "emailAddress",
  PHONE_NUMBER = "phoneNumber",
  COUNTRY = "country",
  NOTES = "notes",
  LOCALES = "locales",
  ALLOW_MARKETING = "allowMarketing",
  POSTAL_CODE = "postalCode",
}

export type CreateWaitlistRequest = {
  productId: string;
  optionId: DefaultableId;
  returnUrl?: string;
  localDate: string;
  contact: BookingContact;
  units: Array<WaitlistUnitItemIdentifier>;
};

export type CustomerContact = {
  /**
   * The full name of the booking holder. Can also be retrieved as an alias for the concatenation of firstName and lastName
   */
  fullName: string | null;
  /**
   * The first name of the booking holder.
   */
  firstName: string | null;
  /**
   * The last name of the booking holder.
   */
  lastName: string | null;
  /**
   * The email address of the booking holder.
   */
  emailAddress: string | null;
  /**
   * The phone number of the booking holder.
   */
  phoneNumber: string | null;
  /**
   * An array of locale values, equivalent to navigator.languages in a browsers environment; representing customer language for booking communications.
   */
  locales: Array<string> | null;
  /**
   * The PO Box of the booking holder or the ticket holder.
   */
  postalCode: string | null;
  /**
   * The country of the booking holder or the ticket holder.
   */
  country: string | null;
  /**
   * Customer-facing public notes for the booking.
   */
  notes: string | null;
  /**
   * The tax ID of the booking holder or the ticket holder.
   */
  taxId: string | null;
  /**
   * The tax ID of the booking holder or the ticket holder.
   */
  title: string | null;
  /**
   * The street address of the booking holder or the ticket holder.
   */
  streetAddress: string | null;
  /**
   * The city of the booking holder or the ticket holder.
   */
  city: string | null;
  /**
   * The state of the booking holder or the ticket holder.
   */
  state: string | null;
  /**
   * Whether the booking holder or the ticket holder allows marketing.
   */
  allowMarketing: boolean;
};

/**
 * The defaultable ID is a string that can be used to identify a defaultable object.
 * It is either a UUID in which case the object is uniquely identified (not defaulted) or
 * it is the string `DEFAULT` in which case the object is defaulted.
 */
export type DefaultableId = string;

export enum DeliveryFormat {
  PDF_URL = "PDF_URL",
  QRCODE = "QRCODE",
  CODE128 = "CODE128",
  PKPASS_URL = "PKPASS_URL",
}

export enum DeliveryMethod {
  VOUCHER = "VOUCHER",
  TICKET = "TICKET",
}

export type DeliveryOption = {
  /**
   * The format in which vouchers for this product are delivered. Each format specifies how the vouchers will be represented:
   * QRCODE: A code presented as a QR Code, commonly used for scanning at entry points.
   * CODE128: A linear barcode format widely used for retail and ticketing purposes.
   * AZTECCODE: A two-dimensional barcode format similar to QR codes but more compact. It is optimized for small spaces and often used in transportation and event ticketing.
   * PDF_URL: A URL linking to a downloadable PDF containing the complete ticket details for this product.
   * PKPASS_URL: A URL for adding the ticket to Apple Wallet (Passbook) for easy access on iOS devices.
   * This field ensures resellers can understand and integrate the appropriate ticket delivery formats specifically associated with this product."
   */
  deliveryFormat: DeliveryFormat;
  /**
   * The string with the value of the delivery option, e.g. value behind the QRCODE, CODE128, AZTECCODE, or URL hosting the file for PDF_URL or PKPASS_URL)
   */
  deliveryValue: string;
};

export type Destination = {
  /**
   * Unique identifier used in the platform to represent the destination.
   */
  id: string;
  /**
   * TRUE` identifies the destination as default, and should therefore rendered and selected first
   */
  default: boolean;
  /**
   * The name of the destination.
   */
  name: string | null;
  /**
   * The title of the destination.
   */
  title: string | null;
  /**
   * The description of the destination.
   */
  shortDescription: string | null;
  /**
   * `TRUE` identifies the destination as featured, and should therefore rendered and selected first
   */
  featured: boolean;
  /**
   * The country the destination is in
   */
  country: string | null;
  contact: DestinationContact;
  /**
   * The latitude of the destination.
   */
  latitude: number | null;
  /**
   * The longitude of the destination.
   */
  longitude: number | null;
  /**
   * The Google Place ID for the destination.
   */
  googlePlaceId: string | null;
  /**
   * The URL of the image that represents the destination.
   */
  bannerImageUrl: string | null;
  /**
   * The URL of the image that represents the destination.
   */
  coverImageUrl: string | null;
  /**
   * The URL of the video that represents the destination.
   */
  videoUrl: string | null;
  /**
   * The Facebook URL for the destination.
   */
  facebookUrl: string | null;
  /**
   * The Google URL for the destination.
   */
  googleUrl: string | null;
  /**
   * The Tripadvisor URL for the destination.
   */
  tripadvisorUrl: string | null;
  /**
   * The Twitter URL for the destination.
   */
  twitterUrl: string | null;
  youtubeUrl: string | null;
  /**
   * The Instagram URL for the destination.
   */
  instagramUrl: string | null;
  /**
   * An array of categories that the destination falls under.
   */
  categories: Array<Category>;
  tags: Array<string>;
  address: string | null;
  notices: Array<Notice>;
};

/**
 * Contact information.
 */
export type DestinationContact = {
  /**
   * Contact name
   */
  name: string | null;
  /**
   * The email support contact for the Supplier.
   */
  email: string | null;
  /**
   * The phone support contact for the Supplier.
   */
  telephone: string | null;
  /**
   * The (snail) mail address support contact for the Supplier.
   */
  address: string | null;
  /**
   * This SHOULD be the website of the Supplier that is separate from the Booking Platform but MAY be a unique destination within the Booking Platform about the Supplier.
   */
  website: string | null;
};

export enum DurationUnit {
  MINUTE = "minute",
  HOUR = "hour",
  DAY = "day",
}

export type ExtendReservationBody = OctoExtendReservationBody;

export type ExtendReservationErrorResponse = OctoExtendReservationErrorResponse;

export type ExtendReservationRequest = OctoExtendReservationRequest & {
  body: ExtendReservationBody;
};

export type Extra = {
  /**
   * Unique identifier for the extra.
   */
  id: string;
  /**
   * Optional internal name for backend usage.
   */
  internalName: string | null;
  /**
   * Optional public-facing title of the extra.
   */
  title: string | null;
  /**
   * Optional detailed description of the extra.
   */
  description: string | null;
  /**
   * Optional reference code for the extra.
   */
  reference: string | null;
  /**
   * Restrictions applicable to the extra.
   */
  restrictions: ExtraRestrictions;
  /**
   * Optional array of starting prices.
   */
  pricingFrom?: Array<Pricing>;
  /**
   * Optional array of pricing details.
   */
  pricing?: Array<Pricing>;
  /**
   * Optional short summary of the extra.
   */
  shortDescription: string | null;
};

export type ExtraItem = {
  /**
   * Unique identifier for the extra item.
   */
  id: string;
  /**
   * Reference ID of the extra.
   */
  extraId: string;
  /**
   * Full extra metadata.
   */
  extra: Extra;
  /**
   * Pricing details for this specific extra item.
   */
  pricing: Pricing;
};

export type ExtraRestrictions = {
  /**
   * Indicates whether this restriction is the default one.
   */
  default: boolean;
  /**
   * Specifies if this restriction is required.
   */
  required: boolean;
  /**
   * Minimum quantity required.
   */
  minQuantity: number;
  /**
   * Maximum quantity allowed (optional).
   */
  maxQuantity: number | null;
};

export type Faq = {
  /**
   * The text of the frequently asked question. This should be a well-phrased question that reflects typical customer concerns or queries about the product (e.g., "Is hotel pickup included?", "What is the cancellation policy?"). Note: FAQs are intentionally repeated at both product and option levels, enabling suppliers to address questions specific to each context. Resellers must combine FAQs from both levels for customer presentation.
   */
  question: string;
  /**
   * The detailed response to the corresponding question. Answers should be accurate, informative, and written in a way that resolves customer uncertainty (e.g., "Yes, hotel pickup is included within a 10-mile radius of the city center.", "Cancellations are free up to 24 hours before the activity.").
   */
  answer: string;
};

export type Font = {
  /**
   * The font id
   */
  id: string;
  /**
   * The font id
   */
  name: string | null;
  normalTtfUrl: string | null;
  italicTtfUrl: string | null;
  boldTtfUrl: string | null;
  boldItalicTtfUrl: string | null;
};

export type GetBookingRequest = OctoGetBookingRequest;

export type GetBookingsRequest = OctoGetBookingsRequest;

export type GetProductRequest = OctoGetProductRequest;

export type GetProductsRequest = OctoGetProductsRequest;

export type GetSupplierRequest = OctoGetSupplierRequest;

export type GetYourGuideActivateBody = {
  /**
   * Secret used to generate OTP codes for GetYourGuide login.
   */
  gygLoginOTPSecret: string;
  /**
   * Supplier ID provided by GetYourGuide.
   */
  gygSupplierId: string;
  /**
   * Supplier name provided by GetYourGuide.
   */
  gygSupplierName: string;
};

export type GetYourGuideActivateRequest = {
  body: GetYourGuideActivateBody;
};

export type GetYourGuideConnection = PartnersConnection & {
  /**
   * The GetYourGuide Connect ID.
   */
  gygConnectId: string;
  /**
   * Email address used to log into GetYourGuide.
   */
  gygLoginEmail: string;
  /**
   * Password used to log into GetYourGuide.
   */
  gygLoginPassword: string;
  /**
   * Secret used to generate OTP codes for login.
   */
  gygLoginOTPSecret?: string;
  /**
   * Optional supplier ID from GetYourGuide.
   */
  gygSupplierId?: string;
  /**
   * Optional supplier name from GetYourGuide.
   */
  gygSupplierName?: string;
  /**
   * Indicates whether the connection is activated.
   */
  gygActivated: boolean;
};

export type Gift = {
  agent: Agent | null;
  alias: string | null;
  amount: number;
  cancellable: boolean;
  cancellation: BookingCancellation | null;
  confirmable: boolean;
  contact: CustomerContact | null;
  currency: string;
  deliveryMethods: Array<DeliveryMethod>;
  giftPayment: GiftPayment | null;
  id: string;
  message: string | null;
  notes: string | null;
  pricing?: Pricing;
  recipient: CustomerContact | null;
  requiredContactFields: Array<ContactField>;
  reseller: Reseller | null;
  resellerReference: string | null;
  seller: Seller | null;
  settlementMethod: SettlementMethod;
  status: BookingStatus;
  supplierReference: string;
  testMode: boolean | null;
  user: User | null;
  utcCreatedAt: string;
  utcUpdatedAt: string;
  utcExpiresAt: string | null;
  utcRedeemedAt: string | null;
  utcConfirmedAt: string | null;
  uuid: string;
  VisibleContactFields: Array<ContactField>;
  voucher: Ticket;
  identity?: Identity;
  identityId?: string;
};

export type GiftIdentities = {
  identity?: Identity;
  identityId?: string;
};

export type GiftPayment = {
  amount: number;
  currency: string;
  giftCode: string;
};

export type GoogleLocalizedText = {
  /**
   * Localized text content.
   */
  text: string;
  /**
   * Language code in BCP-47 format (e.g., en, fr, de).
   */
  language_code: string;
};

export type GoogleLocation = {
  /**
   * Wrapper object containing the place ID.
   */
  location: {
    /**
     * Google Place ID for the location.
     */
    place_id: string;
  };
};

export type GoogleOperator = {
  /**
   * Display name of the operator.
   */
  name: string;
  /**
   * Localized business profile name as shown on Google.
   */
  google_business_profile_name: {
    localized_texts: Array<GoogleLocalizedText>;
  };
  /**
   * Operator’s phone number.
   */
  phone_number: string;
  /**
   * List of associated locations.
   */
  locations: Array<GoogleLocation>;
};

export type GoogleOptionCategory = {
  /**
   * Label representing the Google option category.
   */
  label: string;
};

export type GoogleOptions = {
  /**
   * Optional Google operator details.
   */
  operator: GoogleOperator | null;
  /**
   * Optional rating data (e.g., average score, count).
   */
  rating: GoogleRating | null;
  /**
   * Google landing page URL.
   */
  landing_page: GoogleUrl;
  /**
   * Type of inventory (e.g., TICKETED, SCHEDULED).
   */
  inventory_type: string;
  /**
   * Google list view landing page URL.
   */
  landing_page_list_view: GoogleUrl;
  /**
   * Categories associated with the option.
   */
  option_categories: Array<GoogleOptionCategory>;
  /**
   * Related Google locations (e.g., nearby or alternatives).
   */
  related_locations: Array<GoogleRelatedLocation>;
};

export type GoogleRating = {
  /**
   * Average rating value (e.g., 4.7).
   */
  average_value: number | null;
  /**
   * Total number of ratings.
   */
  rating_count: number | null;
};

export type GoogleRelatedLocation = {
  /**
   * Nested location structure with place ID.
   */
  location: {
    location: {
      /**
       * Google Place ID of the related location.
       */
      place_id: string;
    };
  };
  /**
   * Type of relationship to the main location (e.g., 'NEARBY', 'ALTERNATIVE').
   */
  relation_type: string;
};

export type GoogleUrl = {
  /**
   * Optional URL linking to the Google listing or resource.
   */
  url: string | null;
};

export type Identity = {
  /**
   * A unique ID / UUID generated to identify the identity
   */
  id: string;
  key: string;
};

export type Image = {
  url: string;
  title: string | null;
  caption: string | null;
};

export type Include = {
  /**
   * The ID of the include.
   */
  id: string;
  /**
   * Whether the include is required.
   */
  required: boolean;
  /**
   * The limit of the include.
   */
  limit: number;
  /**
   * The validity days of the include.
   */
  validityDays?: number;
  /**
   * The product ID of the include.
   */
  productId: string;
  product: Product | null;
  optionId: DefaultableId;
  option: Option | null;
};

export type ItineraryItem = {
  /**
   * The name of the itinerary.
   */
  name: string;
  /**
   * The type of the itinerary.
   * Possible values are `START`, `POI`, `END`, `EVENT`. The default is `START`.
   */
  type: ItineraryItemType;
  /**
   * The description of the itinerary.
   */
  description: string | null;
  /**
   * The address of the itinerary.
   */
  address: string | null;
  /**
   * The Google Place ID of the itinerary.
   */
  googlePlaceId: string | null;
  /**
   * The latitude of the itinerary.
   */
  latitude: number | null;
  /**
   * The longitude of the itinerary.
   */
  longitude: number | null;
  /**
   * The travel time of the itinerary.
   */
  travelTime: string | null;
  /**
   * The travel time amount of the itinerary.
   */
  travelTimeAmount: number | null;
  /**
   * The travel time unit of the itinerary.
   */
  travelTimeUnit: DurationUnit | null;
  /**
   * Human readable duration of the option. Duration starts to count on redemption.
   * This field can be hidden by `hide_duration`.
   */
  duration: string | null;
  /**
   * The duration amount of the option.
   * This field can be hidden by `hide_duration`.
   */
  durationAmount: number;
  /**
   * The duration unit. Possible values are `hour`, `minute`, `day`.
   * This field can be hidden by `hide_duration`.
   */
  durationUnit: DurationUnit;
};

export enum ItineraryItemType {
  START = "START",
  POI = "POI",
  END = "END",
  EVENT = "EVENT",
}

export type Label = {
  id: string;
  name: string;
};

export type ListOrdersRequest = {
  contactEmailAddress?: string;
  contactLastName?: string;
  contactPhoneNumber?: string;
  supplierReference?: string;
  utcCreatedAtEnd?: string;
  utcCreatedAtStart?: string;
  utcUpdatedAtEnd?: string;
  utcUpdatedAtStart?: string;
};

export type Mapping = {
  /**
   * Unique identifier for the mapping.
   */
  id: string;
  /**
   * Reference string provided by the reseller.
   */
  resellerReference: string;
  /**
   * Current status of the mapping from the reseller perspective.
   */
  resellerStatus: ResellerStatus;
  /**
   * Display title of the mapping.
   */
  title: string;
  /**
   * Public-facing URL of the mapping.
   */
  url: string;
  /**
   * Optional webhook URL for updates.
   */
  webhookUrl: string | null;
  /**
   * Indicates whether the product option is required.
   */
  optionRequired: boolean;
  /**
   * Indicates whether a unit is required.
   */
  unitRequired: boolean;
  /**
   * Optional linked product ID.
   */
  productId: string | null;
  /**
   * Optional linked option ID.
   */
  optionId: string | null;
  /**
   * Optional linked unit ID.
   */
  unitId: string | null;
  /**
   * Indicates whether the mapping is actively connected.
   */
  connected: boolean;
};

export enum MediaRel {
  LOGO = "LOGO",
  COVER = "COVER",
  GALLERY = "GALLERY",
}

export enum MediaType {
  IMAGE_JPEG = "image/jpeg",
  IMAGE_PNG = "image/png",
  VIDEO_MP4 = "video/mp4",
  VIDEO_AVI = "video/avi",
  EXTERNAL_YOUTUBE = "external/youtube",
  EXTERNAL_VIMEO = "external/vimeo",
}

export enum NetDiscount {
  NONE = "NONE",
  FULL = "FULL",
  SPLIT = "SPLIT",
  PRORATED = "PRORATED",
}

export type Notice = {
  id: string;
  title: string | null;
  shortDescription: string;
  coverImageUrl: string | null;
};

export type OctoAvailabilityCalendar = {
  /**
   * The specific date for querying availability on Availability Calendar endpoint. This field must follow the ISO 8601 date format (e.g., 2024-11-18). It ensures standardized representation of dates across different systems.
   */
  localDate: string;
  /**
   * Indicates whether there is any remaining availability for the specified date.
   * true: Availability exists.
   * false: Fully booked or unavailable.
   */
  available: boolean;
  /**
   * Defines the current status of the availability date:
   * AVAILABLE: Open for booking.
   * FREESALE: Unlimited availability, no capacity limits.
   * SOLD_OUT: No spots available.
   * LIMITED: Less than 50% capacity remaining.
   * CLOSED: The availability is closed.
   */
  status: AvailabilityStatus;
  /**
   * Specifies the number of available slots remaining quantity (highest remaining vacancies from all availabilities of this day). Should be nulled or omitted when status is FREESALE.
   */
  vacancies: number | null;
  /**
   * The total capacity for this availability date.
   */
  capacity: number | null;
  /**
   * Defines the opening hours for this availability, even for start time-based availability. Supports multiple periods for breaks in the day.
   */
  openingHours: Array<OctoOpeningHours>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  unitPricingFrom?: Array<OctoPricingUnit>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricingFrom?: Array<OctoPricing>;
};

export type OctoAvailabilityCalendarErrorResponse = {
  body:
    | OctoErrorInvalidProductId
    | OctoErrorInvalidOptionId
    | OctoErrorBadRequest
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type OctoAvailabilityCheckErrorResponse = {
  body:
    | OctoErrorInvalidProductId
    | OctoErrorInvalidOptionId
    | OctoErrorBadRequest
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type OctoBaseError = {
  /**
   * The error code. A table of possible error codes is shown below.
   */
  error: string;
  /**
   * A human-readable error message will be translated depending on the language provided by the Accept-Language header.
   */
  errorMessage: string;
};

export type OctoBookingCancellationBody = {
  /**
   * A text value describing why the cancellation happened.
   */
  reason?: string;
  /**
   * Whether you want OCTO Cloud to email the guest a copy of their receipt and tickets. (defaults to false)
   */
  force?: boolean;
};

export type OctoBookingCancellationErrorResponse = {
  body:
    | OctoErrorInvalidBookingUuid
    | OctoErrorUnprocessableEntity
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type OctoBookingCancellationRequest = {
  /**
   * The UUID of the booking
   */
  uuid: string;
  body: OctoBookingCancellationBody;
};

export type OctoBookingConfirmationErrorResponse = {
  body:
    | OctoErrorInvalidProductId
    | OctoErrorInvalidOptionId
    | OctoErrorInvalidUnitId
    | OctoErrorInvalidAvailabilityId
    | OctoErrorInvalidBookingUuid
    | OctoErrorUnprocessableEntity
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type OctoBookingReservationErrorResponse = {
  body:
    | OctoErrorInvalidProductId
    | OctoErrorInvalidOptionId
    | OctoErrorInvalidUnitId
    | OctoErrorInvalidAvailabilityId
    | OctoErrorUnprocessableEntity
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type OctoErrorBadRequest = OctoBaseError;

export type OctoErrorForbidden = OctoBaseError;

export type OctoErrorInternalServerError = OctoBaseError;

export type OctoErrorInvalidAvailabilityId = OctoBaseError & {
  /**
   * Missing or invalid `availabilityId` in the request
   */
  availabilityId: string;
};

export type OctoErrorInvalidBookingUuid = OctoBaseError & {
  /**
   * Missing or invalid booking UUID, or if you're confirming the booking the booking may have expired already.
   */
  uuid: string;
};

export type OctoErrorInvalidOptionId = OctoBaseError & {
  /**
   * Missing or invalid `optionId` in the request
   */
  optionId: string;
};

export type OctoErrorInvalidProductId = OctoBaseError & {
  /**
   * Missing or invalid `productId` in the request
   */
  productId: string;
};

export type OctoErrorInvalidUnitId = OctoBaseError & {
  /**
   * Missing or invalid `unitId` in the request
   */
  unitId: string;
};

export type OctoErrorUnauthorized = OctoBaseError;

export type OctoErrorUnprocessableEntity = OctoBaseError;

export type OctoExtendReservationBody = {
  expirationMinutes?: number;
};

export type OctoExtendReservationErrorResponse = {
  body:
    | OctoErrorInvalidBookingUuid
    | OctoErrorUnprocessableEntity
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type OctoExtendReservationRequest = {
  /**
   * The UUID of the booking
   */
  uuid: string;
  body: OctoExtendReservationBody;
};

export type OctoGetBookingRequest = {
  /**
   * The UUID of the booking
   */
  uuid: string;
};

export type OctoGetBookingsRequest = {
  /**
   * The reseller reference on the booking
   */
  resellerReference?: string;
  /**
   * The reference provided by the supplier
   */
  supplierReference?: string;
  /**
   * All bookings made for a specific date
   */
  localDate?: string;
  /**
   * First date of a date range search
   */
  localDateStart?: string;
  /**
   * Last date of a date range search
   */
  localDateEnd?: string;
  /**
   * The product id to filter by
   */
  productId?: string;
  /**
   * The option id to filter by
   */
  optionId?: string;
};

export type OctoGetProductRequest = {
  /**
   * The product id
   */
  id: string;
};

export type OctoGetProductsRequest = {
  [key: string]: unknown;
};

export type OctoGetSupplierRequest = {
  [key: string]: unknown;
};

export type OctoMedia = {
  /**
   * The URL of the media file. The URL must be stable and publicly accessible.
   */
  src: string;
  /**
   * Specifies the type of the media file, which indicates its format and intended usage. Recommended types include: image/jpeg: High-quality compressed images, ideal for general use. Suggested dimensions: 1920x1080 or higher.
   * image/png: Images with transparency or higher visual fidelity, recommended for logos. Suggested dimensions: At least 1000x1000 pixels.
   * video/mp4: Universal video format for high-quality playback. Suggested resolution: 1080p or higher.
   * video/avi: A less common video format; MP4 is generally preferred for compatibility.
   * external/youtube: URL links to YouTube videos for dynamic content. Use a shareable URL format.
   * external/vimeo: URL links to Vimeo-hosted videos for high-quality or private video content.
   */
  type: MediaType;
  /**
   * Defines the relationship of the media file to the supplier's content. Common values include: LOGO: For branding assets like supplier logos.
   * COVER: For primary visual elements representing the supplier.
   * GALLERY: For additional images or videos.
   */
  rel: MediaRel;
  /**
   * The title or name of the media, providing a brief description or identifier for the media file. This helps in organizing and identifying media files (e.g., "Main Attraction Image," "Promotional Video"). This field can be null if no title is provided.
   */
  title: string | null;
  /**
   * A caption providing additional context or information about what is depicted in the media. Captions should be customer-facing and provide insights such as "Overview of the city skyline at sunset" or "Guests enjoying the guided tour." This field can be null if no caption is provided.
   */
  caption: string | null;
  /**
   * Information about the copyright status or usage restrictions of the media. This may include details about ownership, licensing terms, or attribution requirements (e.g., "© 2024 Example Corp, All Rights Reserved"). If null, it is assumed there are no copyright restrictions or attribution requirements.
   */
  copyright: string | null;
};

/**
 * Defines the opening hours for this availability, even for start time-based availability. Supports multiple periods for breaks in the day.
 */
export type OctoOpeningHours = {
  /**
   * The opening time
   */
  from: string;
  /**
   * The closing time
   */
  to: string;
};

export type OctoPricing = {
  /**
   * Represents the advertised marketing price, which must be equal to or higher than pricingFrom.retail. Typically used for strike-through pricing, it highlights the original or component-based value of the product when the retail price reflects a discount or bundled offer. For example, a package product combining multiple components (e.g., hotel + tour + meals) may have a total component value of $500 (original), while the bundled retail price is $400. In such cases, the original price is displayed to show savings.This field should only be shown when it is higher than pricingFrom.retail and must accurately reflect a valid reference price, ensuring transparency and trust.
   */
  original: number;
  /**
   * The supplier’s recommended sale price, including all taxes and fees. This is the price charged to end customers and represents the total cost.
   */
  retail: number;
  /**
   * The wholesale price charged to the reseller, including all taxes and fees. This price reflects the amount the reseller pays to the supplier.
   */
  net: number | null;
  /**
   * Specifies the currency used for the prices provided in the pricingFrom object. The value must adhere to ISO 4217 currency codes (e.g., USD, EUR, JPY) to ensure consistency across systems.
   */
  currency: string;
  /**
   * All pricing is given in integers to avoid floating point rounding issues. e.g. USD = 2 and JPY = 0. To convert a price to decimal you should do: price / (10 ** currencyPrecision) where ** is to the power of e.g. Math.pow(10, currencyPrecision).
   */
  currencyPrecision: number;
  /**
   * This field defines the number of decimal places used for the currency in the pricingFrom object, ensuring precise representation and preventing rounding errors during calculations. For example, in currencies like USD, which have a precision of 2, prices are expressed in cents (e.g., $45.00 is represented as 4500). In currencies like JPY, which have a precision of 0, prices are expressed as whole yen amounts (e.g., ¥4500 is represented as 4500). By aligning with the specific decimal requirements of different currencies, this field guarantees accurate pricing calculations and consistent handling across various currency formats.
   */
  includedTaxes: Array<OctoTax>;
};

export type OctoPricingUnit = OctoPricing & {
  /**
   * ID of the unit this pricing is related to
   */
  unitId: string;
};

export type OctoRequestHeaders = {
  [key: string]: unknown;
};

export type OctoResponseHeaders = {
  [key: string]: unknown;
};

export type OctoTax = {
  /**
   * The name of the tax or fee, such as "VAT", "City Tax", or "Service Charge". This field provides clear labeling of the tax or fee being applied, making the pricing structure easier to interpret.
   */
  name: string;
  /**
   * The value of the tax or fee included in the retail price, expressed in the same currency as the pricingFrom.currency. This value indicates the portion of the end-customer price attributable to the specific tax or fee.
   */
  retail: number;
  original: number;
  /**
   * The value of the tax or fee included in the net price, expressed in the same currency as the pricingFrom.currency. This value indicates the portion of the reseller’s cost attributable to the specific tax or fee.
   */
  net: number | null;
};

export type Offer = {
  /**
   * The title or name of the offer.
   */
  title: string;
  /**
   * The unique code used to apply the offer.
   */
  code: string;
  /**
   * Optional description of the offer.
   */
  description: string | null;
  /**
   * Net discount strategy applied to the offer.
   */
  netDiscount: NetDiscount | null;
  /**
   * Restrictions that determine when the offer is valid.
   */
  restrictions: OfferRestrictions;
  /**
   * Indicates whether the offer can currently be applied.
   */
  usable: boolean;
};

export type OfferCombination = {
  /**
   * ID of the product in the combination.
   */
  productId: string;
  /**
   * ID of the selected option.
   */
  optionId: string;
  /**
   * Code used to apply the offer.
   */
  offerCode: string;
  /**
   * Title of the promotional offer.
   */
  offerTitle: string;
  /**
   * Pricing details for this offer.
   */
  pricing: Pricing;
  /**
   * Optional short description.
   */
  shortDescription?: string;
  /**
   * Units included in this offer.
   */
  units: Array<Unit>;
  /**
   * Optional booking metadata.
   */
  booking: Booking | null;
};

export type OfferComparison = {
  /**
   * ID of the product being compared.
   */
  productId: string;
  /**
   * ID of the product option.
   */
  optionId: string;
  /**
   * Pricing details for this offer.
   */
  pricing: Pricing;
  /**
   * Full product metadata.
   */
  product: Product;
  /**
   * Optional short description for the offer.
   */
  shortDescription?: string;
  /**
   * List of units applicable to this offer.
   */
  units: Array<Unit>;
};

export type OfferDiscount = {
  /**
   * Net price before discount.
   */
  net: number;
  /**
   * Retail price after discount.
   */
  retail: number;
  /**
   * List of taxes included in the discounted price.
   */
  includedTaxes: Array<Tax>;
};

export type OfferRestrictions = {
  /**
   * Minimum number of units allowed.
   */
  minUnits: number | null;
  /**
   * Maximum number of units allowed.
   */
  maxUnits: number | null;
  /**
   * Minimum total price or quantity allowed.
   */
  minTotal: number | null;
  /**
   * Maximum total price or quantity allowed.
   */
  maxTotal: number | null;
  /**
   * List of unit IDs that the restriction applies to.
   */
  unitIds: Array<string>;
};

/**
 * Defines the opening hours for this availability, even for start time-based availability. Supports multiple periods for breaks in the day.
 */
export type OpeningHours = {
  /**
   * The opening time
   */
  from: string;
  /**
   * The closing time
   */
  to: string;
  /**
   * Optional label for how frequently the event occurs (e.g., daily, weekly).
   */
  frequency?: string;
  /**
   * Optional numeric amount representing the interval frequency.
   */
  frequencyAmount?: number;
  /**
   * Optional unit for frequency (e.g., day, week, month).
   */
  frequencyUnit?: string;
};

export type OpeningHoursContent = {
  /**
   * Optional label for how frequently the event occurs (e.g., daily, weekly).
   */
  frequency?: string;
  /**
   * Optional numeric amount representing the interval frequency.
   */
  frequencyAmount?: number;
  /**
   * Optional unit for frequency (e.g., day, week, month).
   */
  frequencyUnit?: string;
};

export type Option = {
  /**
   * A unique identifier for the option within the product. This ID is critical for identifying specific options during bookings or other API interactions.
   */
  id: string;
  /**
   * Indicates whether the option is the default selection.
   * true: This option should be rendered and selected first in customer-facing interfaces.
   * false: The option is not default and requires manual selection.
   */
  default: boolean;
  /**
   * The internal name used by the supplier to refer to the option. This name is for internal or operational purposes and may differ from the public, customer-facing name. The customer-facing name is defined separately in the title field under the octo/content capability.
   */
  internalName: string;
  /**
   * An optional internal code used by the supplier to refer to the product. This field is useful for supplier-specific workflows or cross-referencing. It can be null if no reference code exists for the product.
   */
  reference: string | null;
  /**
   * An array containing all possible start times for the option that can be returned during availability. For example a tour with multiple departure times may have multiple:["09:00", "14:00", "17:00"].
   */
  availabilityLocalStartTimes: Array<string>;
  /**
   * A text description of the option's cancellation policy, providing clear guidelines to customers.
   */
  cancellationCutoff: string;
  /**
   * The numeric value of the cutoff period for cancellations, relative to start time or closing hour (of opening hours product)
   */
  cancellationCutoffAmount: number;
  /**
   * The time unit associated with the cutoff period. Possible values are:
   * hour: Cutoff is measured in hours.
   * minute: Cutoff is measured in minutes.
   * day: Cutoff is measured in days.
   */
  cancellationCutoffUnit: CancellationCutoffUnit;
  /**
   * An array specifying the contact fields required to confirm a booking. These apply to the lead traveler, not individual tickets. Possible values:
   * firstName: The first name of the traveler.
   * lastName: The last name of the traveler.
   * fullName: The full name of the traveler.
   * emailAddress: The email address of the traveler.
   * phoneNumber: The phone number of the traveler.
   * postalCode: The postal code of the traveler.
   * country: The country of the traveler.
   * notes: Optional notes from the traveler.
   * locales: Preferred language/localization preferences.
   */
  requiredContactFields: Array<ContactField>;
  availabilityCutoff: string;
  availabilityCutoffAmount: number;
  availabilityCutoffUnit: DurationUnit;
  /**
   * An array of tags that can be used to filter products.
   */
  tags: Array<string>;
  /**
   * An array of the contact fields that are visible to the user when booking. These just apply to the lead traveller on the booking and not for every ticket.
   */
  visibleContactFields: Array<ContactField>;
  restrictions: OptionRestrictions;
  units: Array<Unit>;
  /**
   * The title of the option. Only present when ventrata/content capability is requested.
   */
  title?: string;
  /**
   * The subtitle of the option. Only present when ventrata/content capability is requested.
   */
  subtitle?: string | null;
  /**
   * The language of the option. Only present when ventrata/content capability is requested.
   */
  language?: string;
  /**
   * The description of the option. Only present when ventrata/content capability is requested.
   */
  shortDescription?: string | null;
  /**
   * Human readable duration of the option. Duration starts to count on redemption.
   * This field can be hidden by `hide_duration`.
   * Only present when ventrata/content capability is requested.
   */
  duration?: string;
  /**
   * The duration amount of the option.
   * This field can be hidden by `hide_duration`.
   * Only present when ventrata/content capability is requested.
   */
  durationAmount?: number;
  /**
   * The duration unit. Possible values are `hour`, `minute`, `day`.
   * This field can be hidden by `hide_duration`.
   * Only present when ventrata/content capability is requested.
   */
  durationUnit?: DurationUnit;
  /**
   * The cover image URL of the option. Only present when ventrata/content capability is requested.
   */
  coverImageUrl?: string | null;
  /**
   * The itinerary of the option. Only present when ventrata/content capability is requested.
   */
  itinerary?: Array<ItineraryItem> | null;
  /**
   * The origin point of the option. Only present when ventrata/content capability is requested.
   */
  fromPoint?: Point | null;
  /**
   * The destination point of the option. Only present when ventrata/content capability is requested.
   */
  toPoint?: Point | null;
  /**
   * Whether this option has pickup available.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupAvailable?: boolean;
  /**
   * Whether pickup is required for this option.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupRequired?: boolean;
  /**
   * Whether pickup is required for this option.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupPoints?: Array<PickupPoint>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricingFrom?: Array<OctoPricing>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Array<OctoPricing>;
  /**
   * Questions for this option. Only present when octo/questions capability is requested.
   */
  questions?: Array<Question>;
  extras?: Array<Extra>;
  packageIncludes?: Array<PackageInclude>;
};

export type OptionContent = {
  /**
   * The title of the option. Only present when ventrata/content capability is requested.
   */
  title?: string;
  /**
   * The subtitle of the option. Only present when ventrata/content capability is requested.
   */
  subtitle?: string | null;
  /**
   * The language of the option. Only present when ventrata/content capability is requested.
   */
  language?: string;
  /**
   * The description of the option. Only present when ventrata/content capability is requested.
   */
  shortDescription?: string | null;
  /**
   * Human readable duration of the option. Duration starts to count on redemption.
   * This field can be hidden by `hide_duration`.
   * Only present when ventrata/content capability is requested.
   */
  duration?: string;
  /**
   * The duration amount of the option.
   * This field can be hidden by `hide_duration`.
   * Only present when ventrata/content capability is requested.
   */
  durationAmount?: number;
  /**
   * The duration unit. Possible values are `hour`, `minute`, `day`.
   * This field can be hidden by `hide_duration`.
   * Only present when ventrata/content capability is requested.
   */
  durationUnit?: DurationUnit;
  /**
   * The cover image URL of the option. Only present when ventrata/content capability is requested.
   */
  coverImageUrl?: string | null;
  /**
   * The itinerary of the option. Only present when ventrata/content capability is requested.
   */
  itinerary?: Array<ItineraryItem> | null;
  /**
   * The origin point of the option. Only present when ventrata/content capability is requested.
   */
  fromPoint?: Point | null;
  /**
   * The destination point of the option. Only present when ventrata/content capability is requested.
   */
  toPoint?: Point | null;
};

export type OptionExtras = {
  extras?: Array<Extra>;
};

export type OptionPackages = {
  packageIncludes?: Array<PackageInclude>;
};

export type OptionPickups = {
  /**
   * Whether this option has pickup available.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupAvailable?: boolean;
  /**
   * Whether pickup is required for this option.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupRequired?: boolean;
  /**
   * Whether pickup is required for this option.
   * This field is only present when the capability `octo/pickups` is requested.
   */
  pickupPoints?: Array<PickupPoint>;
};

export type OptionQuestions = {
  /**
   * Questions for this option. Only present when octo/questions capability is requested.
   */
  questions?: Array<Question>;
};

export type OptionRestrictions = {
  /**
   * The minimum number of units (tickets) that can be purchased in a single booking. A null value indicates no minimum.
   */
  minUnits: number | null;
  /**
   * The maximum number of units (tickets) that can be purchased in a single booking. A null value indicates no maximum.
   */
  maxUnits: number | null;
  /**
   * The minimum number of pax units that can be purchased in a single booking (null = 0).
   */
  minPaxCount: number | null;
  /**
   * The maximum number of pax units that can be purchased in a single booking (null = unlimited).
   */
  maxPaxCount: number | null;
};

export type Order = {
  id: string;
  testMode: boolean;
  settlementMethod: SettlementMethod;
  supplierReference: string;
  quote: boolean;
  status: string;
  utcExpiresAt: string | null;
  utcConfirmedAt: string | null;
  cancellable: boolean;
  confirmable: boolean;
  reseller?: Reseller;
  agent?: Agent;
  contact?: CustomerContact;
  emailReceipt?: boolean;
  bookings: Array<Booking>;
  visibleContactFields: Array<ContactField>;
  requiredContactFields: Array<ContactField>;
  user: User | null;
  seller: Seller | null;
  identity?: Identity;
  identityId?: string;
  offerCombinations?: Array<OfferCombination>;
  giftPayment?: GiftPayment | null;
};

export type OrderGifts = {
  giftPayment?: GiftPayment | null;
};

export type OrderIdentities = {
  identity?: Identity;
  identityId?: string;
};

export type OrderOffers = {
  offerCombinations?: Array<OfferCombination>;
};

export type PackageInclude = {
  /**
   * Include group name or product name.
   */
  title?: string;
  /**
   * Include count.
   */
  count: number;
  /**
   * An array of includes.
   */
  includes: Array<Include>;
};

export type Partner = {
  /**
   * Unique identifier for the partner.
   */
  id: string;
  /**
   * The display name of the partner.
   */
  name: PartnerEnum;
};

export enum PartnerEnum {
  GET_YOUR_GUIDE = "GetYourGuide",
}

export type PartnersConnection = {
  /**
   * Unique identifier for the GetYourGuide connection.
   */
  id: string;
  /**
   * Display name for the connection.
   */
  name: string;
  /**
   * Type of the connection.
   */
  type: string;
};

export type PartnersListConnection = {
  /**
   * The supplier information associated with the connection.
   */
  supplier: Supplier;
  /**
   * The connection details, which could be a generic partner connection or a GetYourGuide connection.
   */
  connection: PartnersConnection | GetYourGuideConnection;
  /**
   * The API key used to authenticate this partner connection.
   */
  apiKey: string;
};

export type PartnersListConnectionsRequest = {
  [key: string]: unknown;
};

export type PartnersListConnectionsRequestHeaders = RequestHeaders;

export type PickupPoint = {
  /**
   * Unique identifier for the pickup point.
   */
  id: string;
  /**
   * Name of the pickup point.
   */
  name: string;
  /**
   * Optional directions to reach the pickup point.
   */
  directions: string | null;
  /**
   * Optional address of the pickup point.
   */
  address: string | null;
  /**
   * Latitude coordinate of the pickup point.
   */
  latitude: number | null;
  /**
   * Longitude coordinate of the pickup point.
   */
  longitude: number | null;
  /**
   * Local date and time of the pickup point.
   */
  localDateTime: string | null;
  /**
   * Local date and time of the pickup point.
   */
  localDateTimeTo: string | null;
  /**
   * Google Place ID associated with the pickup point.
   */
  googlePlaceId: string | null;
  /**
   * Street address of the pickup point.
   */
  street: string | null;
  /**
   * Postal code of the pickup point location.
   */
  postalCode: string | null;
  /**
   * Locality (city or town) of the pickup point.
   */
  locality: string | null;
  /**
   * Region (e.g., state or province) of the pickup point.
   */
  region: string | null;
  /**
   * State of the pickup point.
   */
  state: string | null;
  /**
   * Country of the pickup point.
   */
  country: string | null;
};

export type Point = {
  /**
   * The ID of the point.
   */
  id: string;
  /**
   * The internal name of the point.
   */
  internalName: string | null;
  /**
   * The title of the point.
   */
  title: string | null;
  /**
   * The short description of the point. This is preserved for historical compatibility, but will
   * always be `nil`.
   */
  shortDescription: string | null;
  pointGroup: PointGroup;
};

export type PointGroup = {
  /**
   * The ID of the point group.
   */
  id: string;
  /**
   * The internal name of the point group.
   */
  internalName: string;
  /**
   * The title of the point group.
   */
  title: string;
  /**
   * The short description of the point group.
   */
  shortDescription: string;
};

export type Pricing = {
  /**
   * Represents the advertised marketing price, which must be equal to or higher than pricingFrom.retail. Typically used for strike-through pricing, it highlights the original or component-based value of the product when the retail price reflects a discount or bundled offer. For example, a package product combining multiple components (e.g., hotel + tour + meals) may have a total component value of $500 (original), while the bundled retail price is $400. In such cases, the original price is displayed to show savings.This field should only be shown when it is higher than pricingFrom.retail and must accurately reflect a valid reference price, ensuring transparency and trust.
   */
  original: number;
  /**
   * The supplier’s recommended sale price, including all taxes and fees. This is the price charged to end customers and represents the total cost.
   */
  retail: number;
  /**
   * The wholesale price charged to the reseller, including all taxes and fees. This price reflects the amount the reseller pays to the supplier.
   */
  net: number | null;
  /**
   * Specifies the currency used for the prices provided in the pricingFrom object. The value must adhere to ISO 4217 currency codes (e.g., USD, EUR, JPY) to ensure consistency across systems.
   */
  currency: string;
  /**
   * All pricing is given in integers to avoid floating point rounding issues. e.g. USD = 2 and JPY = 0. To convert a price to decimal you should do: price / (10 ** currencyPrecision) where ** is to the power of e.g. Math.pow(10, currencyPrecision).
   */
  currencyPrecision: number;
  /**
   * This field defines the number of decimal places used for the currency in the pricingFrom object, ensuring precise representation and preventing rounding errors during calculations. For example, in currencies like USD, which have a precision of 2, prices are expressed in cents (e.g., $45.00 is represented as 4500). In currencies like JPY, which have a precision of 0, prices are expressed as whole yen amounts (e.g., ¥4500 is represented as 4500). By aligning with the specific decimal requirements of different currencies, this field guarantees accurate pricing calculations and consistent handling across various currency formats.
   */
  includedTaxes: Array<Tax>;
  offerDiscount?: OfferDiscount | null;
  extraId?: Array<string>;
};

export type PricingExtras = {
  extraId?: Array<string>;
};

export type PricingOffers = {
  offerDiscount?: OfferDiscount | null;
};

export enum PricingPer {
  BOOKING = "BOOKING",
  UNIT = "UNIT",
}

export type PricingUnit = {
  /**
   * Represents the advertised marketing price, which must be equal to or higher than pricingFrom.retail. Typically used for strike-through pricing, it highlights the original or component-based value of the product when the retail price reflects a discount or bundled offer. For example, a package product combining multiple components (e.g., hotel + tour + meals) may have a total component value of $500 (original), while the bundled retail price is $400. In such cases, the original price is displayed to show savings.This field should only be shown when it is higher than pricingFrom.retail and must accurately reflect a valid reference price, ensuring transparency and trust.
   */
  original: number;
  /**
   * The supplier’s recommended sale price, including all taxes and fees. This is the price charged to end customers and represents the total cost.
   */
  retail: number;
  /**
   * The wholesale price charged to the reseller, including all taxes and fees. This price reflects the amount the reseller pays to the supplier.
   */
  net: number | null;
  /**
   * Specifies the currency used for the prices provided in the pricingFrom object. The value must adhere to ISO 4217 currency codes (e.g., USD, EUR, JPY) to ensure consistency across systems.
   */
  currency: string;
  /**
   * All pricing is given in integers to avoid floating point rounding issues. e.g. USD = 2 and JPY = 0. To convert a price to decimal you should do: price / (10 ** currencyPrecision) where ** is to the power of e.g. Math.pow(10, currencyPrecision).
   */
  currencyPrecision: number;
  /**
   * This field defines the number of decimal places used for the currency in the pricingFrom object, ensuring precise representation and preventing rounding errors during calculations. For example, in currencies like USD, which have a precision of 2, prices are expressed in cents (e.g., $45.00 is represented as 4500). In currencies like JPY, which have a precision of 0, prices are expressed as whole yen amounts (e.g., ¥4500 is represented as 4500). By aligning with the specific decimal requirements of different currencies, this field guarantees accurate pricing calculations and consistent handling across various currency formats.
   */
  includedTaxes: Array<Tax>;
  /**
   * ID of the unit this pricing is related to
   */
  unitId: string;
  extraPricing?: Array<Pricing>;
};

export type PricingUnitExtras = {
  extraPricing?: Array<Pricing>;
};

export type Product = {
  /**
   * The unique identifier for the product, used across the platform to check availability, create bookings, etc. This identifier must be unique within the scope of the supplier’s system to ensure accurate referencing and operations.
   */
  id: string;
  /**
   * The internal name used by the supplier to refer to the product. This name is for internal or operational purposes and may differ from the public, customer-facing name. The customer-facing name is defined separately in the title field under the octo/content capability.
   */
  internalName: string;
  /**
   * An optional internal code used by the supplier to refer to the product. This field is useful for supplier-specific workflows or cross-referencing. It can be null if no reference code exists for the product.
   */
  reference: string | null;
  /**
   * The language code specifying the primary language in which the product operates. It must conform to the IETF BCP 47 standard, which defines language tags for localization (e.g., en-US for American English, fr-FR for French (France), es-ES for Spanish (Spain)).
   */
  locale: string;
  /**
   * The IANA Time Zone identifier indicating the product's location (e.g., America/New_York, Europe/London).
   */
  timeZone: string;
  /**
   * Indicates whether an availabilityId is required when creating a booking. If set to false, bookings can be made without specifying a travel date, creating open-dated bookings.
   */
  allowFreesale: boolean;
  /**
   * Indicates whether the customer’s tickets or vouchers are delivered immediately after the booking is confirmed. If false, resellers must manage delayed ticket delivery processes.
   */
  instantConfirmation: boolean;
  /**
   * This indicates whether the Reseller can expect immediate delivery of the customer's tickets. If `false` then the Reseller MUST be able to delay delivery of the tickets to the customer.
   */
  instantDelivery: boolean;
  /**
   * Indicates whether an availabilityId is required when creating a booking. If set to false, bookings can be made without specifying a travel date, creating open-dated bookings.
   */
  availabilityRequired: boolean;
  /**
   * Specifies the type of availability for the product:
   * START_TIME: For products with fixed departure times (e.g., walking tour at set times during the day).
   * OPENING_HOURS: For products where customers select a date and can visit anytime during operating hours (e.g., museums general admission ticket valid at any time when museum is open).
   */
  availabilityType: AvailabilityType;
  /**
   * Lists the formats in which tickets or vouchers for this product are delivered. Each format specifies how the tickets or vouchers will be represented:
   * QRCODE: A code presented as a QR Code, commonly used for scanning at entry points.
   * CODE128: A linear barcode format widely used for retail and ticketing purposes.
   * AZTECCODE: A two-dimensional barcode format similar to QR codes but more compact. It is optimized for small spaces and often used in transportation and event ticketing.
   * PDF_URL: A URL linking to a downloadable PDF containing the complete ticket details for this product.
   * PKPASS_URL: A URL for adding the ticket to Apple Wallet (Passbook) for easy access on iOS devices.
   * This field ensures resellers can understand and integrate the appropriate ticket delivery formats specifically associated with this product.
   */
  deliveryFormats: Array<DeliveryFormat>;
  /**
   * Specifies all supported methods of how tickets or vouchers for this product are delivered in the booking response:
   * TICKET: Delivered individually per unit in the booking, where each person or unit receives a separate ticket.
   * VOUCHER: Delivered as a single voucher for the entire booking, consolidating all units under one document.
   * This field ensures clarity on the format of ticket or voucher delivery to resellers and customers.
   */
  deliveryMethods: Array<DeliveryMethod>;
  /**
   * Specifies how the product can be redeemed by the customer:
   * DIGITAL: The ticket or voucher must be presented, either scanned from a digital device (e.g., smartphone) or as a printed copy. Redemption requires a valid voucher or ticket, even in digital form.
   * MANIFEST: The customer’s name, reference, or other information is checked against a manifest by the supplier. Redemption does not require a ticket or voucher.
   * PRINT: A physical printed ticket or voucher is strictly required for redemption and must be presented at the time of use.
   * This field ensures resellers and customers understand the specific requirements for redeeming this product.
   */
  redemptionMethod: RedemptionMethod;
  tags: Array<string>;
  settlementMethods: Array<SettlementMethod>;
  freesaleDurationAmount: number;
  freesaleDurationUnit: DurationUnit;
  options: Array<Option>;
  /**
   * Country code for this product. Only present when ventrata/content capability is requested.
   */
  country?: string;
  /**
   * Location for this product. Only present when ventrata/content capability is requested.
   */
  location?: string;
  /**
   * Destination for this product. Only present when ventrata/content capability is requested.
   */
  destination?: Destination;
  /**
   * Alert message for this product. Only present when ventrata/content capability is requested.
   */
  alert?: string;
  /**
   * Title for this product. Only present when ventrata/content capability is requested.
   */
  title?: string;
  /**
   * Subtitle for this product. Only present when ventrata/content capability is requested.
   */
  subtitle?: string;
  /**
   * Description for this product. Only present when ventrata/content capability is requested.
   */
  description?: string;
  /**
   * Short description for this product. Only present when ventrata/content capability is requested.
   */
  shortDescription?: string;
  /**
   * Categories for this product. Only present when ventrata/content capability is requested.
   */
  categories?: Array<Category>;
  /**
   * Inclusions for this product. Only present when ventrata/content capability is requested.
   */
  inclusions?: Array<string>;
  /**
   * Exclusions for this product. Only present when ventrata/content capability is requested.
   */
  exclusions?: Array<string>;
  /**
   * Highlights for this product. Only present when ventrata/content capability is requested.
   */
  highlights?: Array<string>;
  /**
   * Whether this product is point to point or not. Only present when ventrata/content capability is requested.
   */
  pointToPoint?: boolean;
  /**
   * Booking terms for this product. Only present when ventrata/content capability is requested.
   */
  bookingTerms?: string;
  /**
   * Privacy terms for this product. Only present when ventrata/content capability is requested.
   */
  privacyTerms?: string;
  /**
   * Redemption instructions for this product. Only present when ventrata/content capability is requested.
   */
  redemptionInstructions?: string;
  /**
   * Cancellation policy for this product. Only present when ventrata/content capability is requested.
   */
  cancellationPolicy?: string;
  /**
   * FAQs for this product. Only present when ventrata/content capability is requested.
   */
  faqs?: Array<Faq>;
  coverImageUrl?: string;
  bannerImageUrl?: string;
  videoUrl?: string;
  /**
   * Gallery image URLs for this product. Only present when ventrata/content capability is requested.
   */
  galleryImages?: Array<Image>;
  /**
   * Banner image URLs for this product. Only present when ventrata/content capability is requested.
   */
  bannerImages?: Array<Image>;
  googlePlaceId?: string;
  address?: string;
  keywords?: Array<string>;
  tagline?: string;
  brand?: Brand;
  /**
   * Is on the object when Pricing capability is requested. Default currency for this product, if you omit the currency parameter on future endpoints this is the value the reservation system will fallback to.
   */
  defaultCurrency?: string;
  /**
   * Is on the object when Pricing capability is requested. All the possible currencies that we accept for this product.
   */
  availableCurrencies?: Array<string>;
  /**
   * Is on the object when Pricing capability is requested. Indicates whether the pricing is per unit (most common), or per booking. Pricing which is per booking is common for private charters or group booking products where the price is the same regardless of how many tickets are purchased.
   */
  pricingPer?: PricingPer;
  includeTax?: boolean;
  isPackage?: boolean;
  packageBookingAvailabilityRequired?: boolean;
  googleOptions?: Array<GoogleOptions>;
};

export type ProductContent = {
  /**
   * Country code for this product. Only present when ventrata/content capability is requested.
   */
  country?: string;
  /**
   * Location for this product. Only present when ventrata/content capability is requested.
   */
  location?: string;
  /**
   * Destination for this product. Only present when ventrata/content capability is requested.
   */
  destination?: Destination;
  /**
   * Alert message for this product. Only present when ventrata/content capability is requested.
   */
  alert?: string;
  /**
   * Title for this product. Only present when ventrata/content capability is requested.
   */
  title?: string;
  /**
   * Subtitle for this product. Only present when ventrata/content capability is requested.
   */
  subtitle?: string;
  /**
   * Description for this product. Only present when ventrata/content capability is requested.
   */
  description?: string;
  /**
   * Short description for this product. Only present when ventrata/content capability is requested.
   */
  shortDescription?: string;
  /**
   * Categories for this product. Only present when ventrata/content capability is requested.
   */
  categories?: Array<Category>;
  /**
   * Inclusions for this product. Only present when ventrata/content capability is requested.
   */
  inclusions?: Array<string>;
  /**
   * Exclusions for this product. Only present when ventrata/content capability is requested.
   */
  exclusions?: Array<string>;
  /**
   * Highlights for this product. Only present when ventrata/content capability is requested.
   */
  highlights?: Array<string>;
  /**
   * Whether this product is point to point or not. Only present when ventrata/content capability is requested.
   */
  pointToPoint?: boolean;
  /**
   * Booking terms for this product. Only present when ventrata/content capability is requested.
   */
  bookingTerms?: string;
  /**
   * Privacy terms for this product. Only present when ventrata/content capability is requested.
   */
  privacyTerms?: string;
  /**
   * Redemption instructions for this product. Only present when ventrata/content capability is requested.
   */
  redemptionInstructions?: string;
  /**
   * Cancellation policy for this product. Only present when ventrata/content capability is requested.
   */
  cancellationPolicy?: string;
  /**
   * FAQs for this product. Only present when ventrata/content capability is requested.
   */
  faqs?: Array<Faq>;
  coverImageUrl?: string;
  bannerImageUrl?: string;
  videoUrl?: string;
  /**
   * Gallery image URLs for this product. Only present when ventrata/content capability is requested.
   */
  galleryImages?: Array<Image>;
  /**
   * Banner image URLs for this product. Only present when ventrata/content capability is requested.
   */
  bannerImages?: Array<Image>;
  googlePlaceId?: string;
  address?: string;
  keywords?: Array<string>;
  tagline?: string;
  brand?: Brand;
};

export type ProductGoogle = {
  googleOptions?: Array<GoogleOptions>;
};

export type ProductPackages = {
  isPackage?: boolean;
  packageBookingAvailabilityRequired?: boolean;
};

export type ProductPricing = {
  /**
   * Is on the object when Pricing capability is requested. Default currency for this product, if you omit the currency parameter on future endpoints this is the value the reservation system will fallback to.
   */
  defaultCurrency?: string;
  /**
   * Is on the object when Pricing capability is requested. All the possible currencies that we accept for this product.
   */
  availableCurrencies?: Array<string>;
  /**
   * Is on the object when Pricing capability is requested. Indicates whether the pricing is per unit (most common), or per booking. Pricing which is per booking is common for private charters or group booking products where the price is the same regardless of how many tickets are purchased.
   */
  pricingPer?: PricingPer;
  includeTax?: boolean;
};

export type Question = {
  /**
   * Unique identifier used in the platform to represent the question.
   */
  id: string;
  /**
   * The question that should be asked to the customer.
   */
  label: string | null;
  /**
   * A hint to help the customer answer the question.
   */
  hint: string | null;
  /**
   * The maximum length of the answer to the question.
   */
  maxLength: number | null;
  /**
   * The type of input that should be used to answer the question. Possible values are `radio`, `select`, `textarea`.
   */
  inputType: QuestionInputType;
  /**
   * `TRUE` identifies the question as required, and should therefore be answered by the customer
   */
  required: boolean;
  /**
   * The options that the customer can select from. Only present when `inputType` is `radio` or `select`.
   */
  selectOptions: Array<SelectOption>;
  coverImageUrl: string | null;
  /**
   * Description A hint to help the customer answer the question.
   */
  description: string | null;
  shortDescription: string | null;
  internalName: string | null;
  /**
   * Title The question that should be asked to the customer.
   */
  title: string | null;
};

export type QuestionAnswer = {
  /**
   * Unique identifier used in the platform to represent the question.
   */
  id: string;
  /**
   * The question that should be asked to the customer.
   */
  label: string | null;
  /**
   * A hint to help the customer answer the question.
   */
  hint: string | null;
  /**
   * The maximum length of the answer to the question.
   */
  maxLength: number | null;
  /**
   * The type of input that should be used to answer the question. Possible values are `radio`, `select`, `textarea`.
   */
  inputType: QuestionInputType;
  /**
   * `TRUE` identifies the question as required, and should therefore be answered by the customer
   */
  required: boolean;
  /**
   * The options that the customer can select from. Only present when `inputType` is `radio` or `select`.
   */
  selectOptions: Array<SelectOption>;
  coverImageUrl: string | null;
  /**
   * Description A hint to help the customer answer the question.
   */
  description: string | null;
  shortDescription: string | null;
  internalName: string | null;
  /**
   * Title The question that should be asked to the customer.
   */
  title: string | null;
  /**
   * Unique identifier used in the platform to represent the question.
   */
  questionId: string;
  /**
   * The answer to the question.
   */
  value?: string;
};

export enum QuestionInputType {
  RADIO = "radio",
  SELECT = "select",
  TEXT_AREA = "textArea",
}

export enum RedemptionMethod {
  DIGITAL = "DIGITAL",
  PRINT = "PRINT",
  MANIFEST = "MANIFEST",
}

export enum Refund {
  FULL = "FULL",
  PARTIAL = "PARTIAL",
  NONE = "NONE",
}

export type RequestHeaders = OctoRequestHeaders;

export type Reseller = {
  /**
   * A unique ID / UUID generated to identify the reseller.
   */
  id: string;
  /**
   * Reseller name.
   */
  name: string;
  /**
   * Reseller reference.
   */
  reference: string | null;
  /**
   * An array of tags that can be used to filter.
   */
  tags: Array<string>;
};

export enum ResellerStatus {
  ACTIVE = "ACTIVE",
  DISABLED = "DISABLED",
  DRAFT = "DRAFT",
}

export type Resource = {
  /**
   * Unique identifier for the resource.
   */
  id: string;
  /**
   * Display name of the resource.
   */
  title: string;
  /**
   * Indicates whether the resource has seating.
   */
  seating: boolean;
  /**
   * List of seats available in this resource.
   */
  seats: Array<Seat>;
};

export type ResourceAllocation = {
  /**
   * Unique identifier for the resource allocation.
   */
  id: string;
  /**
   * ID of the associated resource group.
   */
  resourceGroupId: string;
  /**
   * Full resource group object.
   */
  resourceGroup: ResourceGroup;
  /**
   * ID of the assigned resource.
   */
  resourceId: string;
  /**
   * Full resource object.
   */
  resource: Resource;
  /**
   * Number of passengers allocated to the resource.
   */
  paxCount: number;
  /**
   * IDs of the allocated seats.
   */
  seatIds: Array<string>;
  /**
   * Full seat objects allocated to the resource.
   */
  seats: Array<Seat>;
};

export type ResourceGroup = {
  /**
   * Unique identifier for the resource group.
   */
  id: string;
  /**
   * Display title of the resource group.
   */
  title: string;
  /**
   * Indicates whether the group allows resource splitting.
   */
  split: boolean;
};

export type ResponseHeaders = OctoResponseHeaders;

export type Seat = {
  /**
   * Unique identifier for the seat.
   */
  id: string;
  /**
   * Human-readable label or name of the seat.
   */
  title: string;
  /**
   * Column position of the seat.
   */
  column: number;
  /**
   * Row position of the seat.
   */
  row: number;
};

export type SelectOption = {
  /**
   * The label that will be shown to the customer.
   */
  label: string;
  /**
   * The value that will be sent to the supplier.
   */
  value: string;
};

export type Seller = {
  id: string;
  name: string;
  reference: string | null;
  tags: Array<string>;
  emailAddress: string | null;
  phoneNumber: string | null;
};

export enum SettlementMethod {
  DEFERRED = "deferred",
  DEPOSIT = "deposit",
  DIRECT = "direct",
  VOUCHER = "voucher",
  WHOLESALE = "wholesale",
}

export type Supplier = {
  /**
   * Unique identifier for the supplier, used across the platform to represent this supplier entity. This identifier must be unique within the supplier system.
   */
  id: string;
  /**
   * Name used to identify the supplier within the platform. This name is typically recognized by end customers as the official name of the supplier's business entity. It should clearly represent the supplier's brand or identity to ensure consistency across platforms. For larger multi-venue suppliers, this represents the parent entity's name. Other associated entities or sub-divisions can be specified using the octo/content capability through the venues field.
   */
  name: string;
  /**
   * The base URL that is prepended to all other API paths. The value should not contain a trailing slash and must follow URI format.
   */
  endpoint: string;
  /**
   * A structured object containing defined contact fields related to the supplier. This includes various communication methods (e.g., website, email, phone) and address information. It ensures standardized contact details that facilitate seamless communication with the supplier for both customers and partners.
   */
  contact: SupplierContact;
  /**
   * A brief, customer-facing description of the supplier. This field provides a concise overview of the supplier's business and may be null if no description is available.
   */
  shortDescription?: string | null;
  /**
   * A list of supplier media files hosted at stable URLs. Media enhances the visual and informational representation of the supplier, such as logos and supporting images. This array can be null if no media is available. Note: Media details are intentionally repeated at various levels.
   */
  media?: Array<OctoMedia>;
  country?: string | null;
  destinations?: Array<Destination>;
};

export type SupplierContact = {
  /**
   * The supplier's official website URL. This should link directly to the supplier's primary website or a dedicated page about the supplier within a supplier system. The URL should not reference a general supplier system but a specific, identifiable supplier presence. This field can be null if no website is available.
   */
  website: string | null;
  /**
   * The email address for customer service inquiries, primarily for end customers. This should be a direct and monitored email address for resolving queries and providing support. The field may be null if email support is not offered or the email address is unavailable or not provided in supplier system.
   */
  email: string | null;
  /**
   * The customer service telephone number for end customers, formatted according to the E.164 standard. This format includes the country code followed by the national number, with no spaces, dashes, or special characters. This field can be null if telephone support is unavailable or not provided in supplier system.
   */
  telephone: string | null;
  /**
   * The full mailing address of the location as a single string. It includes street address, city, state, postal code, and country. If no address is provided, this field can be null. For structured details, use the additional address-related fields
   */
  address: string | null;
};

export type SupplierContent = {
  country?: string | null;
  destinations?: Array<Destination>;
};

export type Tax = {
  /**
   * The name of the tax or fee, such as "VAT", "City Tax", or "Service Charge". This field provides clear labeling of the tax or fee being applied, making the pricing structure easier to interpret.
   */
  name: string;
  /**
   * The value of the tax or fee included in the retail price, expressed in the same currency as the pricingFrom.currency. This value indicates the portion of the end-customer price attributable to the specific tax or fee.
   */
  retail: number;
  original: number;
  /**
   * The value of the tax or fee included in the net price, expressed in the same currency as the pricingFrom.currency. This value indicates the portion of the reseller’s cost attributable to the specific tax or fee.
   */
  net: number | null;
  shortDescription: string | null;
};

export type Ticket = {
  /**
   * Specifies how the voucher can be redeemed by the customer:
   * DIGITAL: The voucher must be presented, either scanned from a digital device (e.g., smartphone) or as a printed copy. Redemption requires a valid voucher or ticket, even in digital form.
   * MANIFEST: The customer’s name, reference, or other information is checked against a manifest by the supplier. Redemption does not require a ticket or voucher.
   * PRINT: A physical printed voucher is strictly required for redemption and must be presented at the time of use.
   * This field ensures resellers and customers understand the specific requirements for redeeming this booking.
   */
  redemptionMethod: RedemptionMethod;
  /**
   * An ISO8601 date time in UTC at when the voucher was redeemed, if applicable.
   */
  utcRedeemedAt: string | null;
  /**
   * All possible delivery options supplier accepts, in the order of supplier preference
   */
  deliveryOptions: Array<DeliveryOption>;
  /**
   * An ISO8601 date time in UTC at when the voucher was redeemed, if applicable.
   */
  utcNoshowedAt: string | null;
};

export type TourGroup = {
  /**
   * Unique identifier for the tour group.
   */
  id: string;
  /**
   * Internal name used for internal reference or system logic.
   */
  internalName: string;
  /**
   * Public-facing title of the tour group.
   */
  title: string;
};

export type Uuid = string;

export type Unit = {
  /**
   * The unique identifier for this unit within the scope of the option. This ID ensures that each unit can be uniquely referenced and managed.
   */
  id: string;
  /**
   * An internal name for the unit, used for backend purposes and not visible to customers. This field helps with identifying and managing the unit in the supplier’s system.
   */
  internalName: string;
  /**
   * An optional internal reference code used by the supplier for identification purposes. This field may not be unique and is meant for operational use.
   */
  reference: string | null;
  /**
   * This is the base unit type for this unit definition. A value of TRAVELLER must only be used in replacement of ADULT, CHILD, INFANT, YOUTH, STUDENT, MILITARY or SENIOR.
   */
  type: UnitType;
  /**
   * Lists the contact information required per ticket for the unit. Possible values include:
   * firstName: First name of the ticket holder.
   * lastName: Last name of the ticket holder.
   * fullName: Full name, as a combination of first and last name.
   * emailAddress: Email address of the ticket holder.
   * phoneNumber: Phone number of the ticket holder.
   * postalCode: Postal code for identification purposes.
   * country: Country code (ISO 3166-1 alpha-2).
   * notes: Additional notes or special instructions.
   * locales: Locale preferences (IETF BCP 47 tags).
   */
  requiredContactFields: Array<ContactField>;
  /**
   * This is an array of tags that can be used to filter the units.
   */
  tags: Array<string>;
  /**
   * This is the array of the contact information PER ticket that the supplier expects.
   */
  visibleContactFields: Array<ContactField>;
  /**
   * Specifies booking or usage restrictions for the unit.
   */
  restrictions: UnitRestrictions;
  /**
   * Title for this unit. Only present when octo/content capability is requested.
   */
  title?: string;
  /**
   * Plural title for this unit. Only present when octo/content capability is requested.
   */
  titlePlural?: string;
  /**
   * Subtitle for this unit. Only present when octo/content capability is requested.
   */
  subtitle?: string | null;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricingFrom?: Array<Pricing>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Array<Pricing>;
  /**
   * Questions for this unit. Only present when octo/questions capability is requested.
   */
  questions?: Array<Question>;
  extras?: Array<Extra>;
};

export type UnitContent = {
  /**
   * Title for this unit. Only present when octo/content capability is requested.
   */
  title?: string;
  /**
   * Plural title for this unit. Only present when octo/content capability is requested.
   */
  titlePlural?: string;
  /**
   * Subtitle for this unit. Only present when octo/content capability is requested.
   */
  subtitle?: string | null;
};

export type UnitExtras = {
  extras?: Array<Extra>;
};

export type UnitItem = {
  /**
   * The id of the unit, this will be unique to the option.
   */
  uuid?: string;
  /**
   * A reference the reseller uses to identify the unit within all bookings.
   */
  resellerReference: string | null;
  /**
   * A reference the supplier uses to identify the unit within all bookings.
   */
  supplierReference: string | null;
  /**
   * This MUST be a unique identifier within the scope of the option.
   */
  unitId: string;
  unit?: Unit;
  /**
   * The status of the booking, possible values are:
   * `ON_HOLD` The booking is pending confirmation, this is the default value when you first create the booking.
   * `EXPIRED` If the booking is not confirmed before the expiration hold expires, it goes into an expired state.
   * `CONFIRMED` Once the confirmation call is made the booking is ready to be used.
   * `CANCELLED` If the booking is cancelled.
   * `PENDING` If the booking is pending outside availability confirmation.
   * `REDEEMED` If the booking is already redeemed.
   */
  status: BookingStatus;
  /**
   * The ISO8601 date in UTC indicating when the ticket was used at the attraction.
   */
  utcRedeemedAt: string | null;
  /**
   * Contact details for the guests that will attend the tour/attraction. Contact Body can be applied to both the booking object (the main reservation) or the unit object (individual ticket holders - if the supplier requires this information)
   */
  contact?: CustomerContact;
  ticket: Ticket | null;
  /**
   * The id of the unit, this will be unique to the option.
   */
  id?: string;
  /**
   * An alias for the unit.
   */
  alias: string | null;
  /**
   * The id of the unit, this will be unique to the option.
   */
  rebookingUuid: string | null;
  /**
   * The id of the unit, this will be unique to the option.
   */
  rebookingUnitItemUuid: string | null;
  /**
   * The id of the unit, this will be unique to the option.
   */
  originalRebookingUuid: string | null;
  /**
   * The id of the unit, this will be unique to the option.
   */
  originalRebookingUnitItemUuid: string | null;
  /**
   * The RFC 3339 date in UTC indicating when the ticket was rebooked.
   */
  utcRebookedAt: string | null;
  utcNoshowedAt: string | null;
  requiredContactFields?: Array<string>;
  visibleContactFields?: Array<string>;
  unitType?: UnitType;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Pricing;
  /**
   * Questions for this unit item. Only present when octo/questions capability is requested.
   */
  questionAnswers?: Array<QuestionAnswer>;
};

export type UnitItemIdentifier = {
  /**
   * The unit item unit ID.
   */
  uuid?: string;
  /**
   * A unique UUID to identify the unit, same as the booking uuid except per unit.
   */
  unitId?: string;
  unitType?: string;
  /**
   * Your reference for this booking. Also known as a Voucher Number.
   */
  resellerReference?: string;
  /**
   * The alias of the unit item.
   */
  alias?: string;
};

export type UnitItemPricing = {
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Pricing;
};

export type UnitItemQuestions = {
  /**
   * Questions for this unit item. Only present when octo/questions capability is requested.
   */
  questionAnswers?: Array<QuestionAnswer>;
};

export type UnitPricing = {
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricingFrom?: Array<Pricing>;
  /**
   * Is on the object when Pricing capability is requested.
   */
  pricing?: Array<Pricing>;
};

export type UnitQuestions = {
  /**
   * Questions for this unit. Only present when octo/questions capability is requested.
   */
  questions?: Array<Question>;
};

export type UnitRestrictions = {
  /**
   * Minimum age to purchase the unit.
   */
  minAge: number;
  /**
   * Maximum age to purchase the unit.
   */
  maxAge: number;
  /**
   * Indicates if identification (e.g., student ID) is required for redemption.
   */
  idRequired: boolean;
  /**
   * Minimum number of units that must be purchased (e.g., 2 tickets). Null means no minimum.
   */
  minQuantity: number | null;
  /**
   * Maximum number of units allowed in a single booking. Null means unlimited.
   */
  maxQuantity: number | null;
  /**
   * The number of people each unit represents (e.g., 1 family ticket = 4 pax).
   */
  paxCount: number;
  /**
   * Specifies if this unit must be accompanied by another unit (e.g., an infant ticket must be purchased with an adult ticket). Array of unit IDs which must be booked together.
   */
  accompaniedBy: Array<string>;
  /**
   * Minimum height required for this unit (e.g., for amusement park rides).
   */
  minHeight?: number;
  /**
   * Maximum height allowed.
   */
  maxHeight?: number;
  /**
   * Unit of height measurement (e.g., "cm" or "in") used for values of minHeight, maxHeight.
   */
  heightUnit?: string;
  /**
   * Minimum weight required.
   */
  minWeight?: number;
  /**
   * Maximum weight allowed.
   */
  maxWeight?: number;
  /**
   * Unit of weight measurement (e.g., "kg" or "lb") used for values of minWeight, maxWeight.
   */
  weightUnit?: string;
  /**
   * This is whether this unit is required to be chosen for purchase
   */
  required: boolean;
  accompaniedByRatio: number | null;
};

export enum UnitType {
  ADULT = "ADULT",
  YOUTH = "YOUTH",
  CHILD = "CHILD",
  INFANT = "INFANT",
  FAMILY = "FAMILY",
  SENIOR = "SENIOR",
  STUDENT = "STUDENT",
  MILITARY = "MILITARY",
  OTHER = "OTHER",
}

export type User = {
  id: string;
  name: string;
  reference: string | null;
  tags: Array<string>;
  emailAddress: string;
  phoneNumber: string | null;
};

export type Waitlist = {
  id: string;
  productId: string;
  optionId: DefaultableId;
  localDate: string;
  units: Array<WaitlistUnitIdentifier>;
  contact: CustomerContact | null;
};

export type WaitlistUnitIdentifier = {
  quantity: number;
  unitId: string;
};

export type WaitlistUnitItemIdentifier = {
  id: string;
  quantity?: number;
};

export type Webhook = {
  /**
   * Unique identifier of the webhook.
   */
  id: string;
  /**
   * Event that triggers the webhook.
   */
  event: WebhookEvent;
  /**
   * Target URL where the webhook payload is sent.
   */
  url?: string;
  /**
   * Whether to retry delivery if an error occurs.
   */
  retryOnError: boolean;
  /**
   * Whether to format the payload using the contact's preferred language.
   */
  useContactLanguage: boolean;
  /**
   * Custom headers to include in the webhook request.
   */
  headers: {
    [key: string]: string;
  };
  /**
   * List of capability identifiers associated with this webhook.
   */
  capabilities: Array<Capability>;
};

export enum WebhookEvent {
  BOOKING_UPDATE = "booking_update",
  AVAILABILITY_UPDATE = "availability_update",
}

export type WhoIAm = {
  supplier: Supplier;
  connection: GetYourGuideConnection | PartnersConnection;
  partner: Partner;
  reseller: Reseller;
  checkout: unknown;
  operator: unknown;
  terminal: unknown;
};

export type WhoIAmRequest = {
  [key: string]: unknown;
};

/**
 * The UUID of the booking
 */
export type BookingConfirmationRequestUuid = string;

/**
 * A list of the Capabilities (their IDs) initialized with your request. ventrata/getyourguide capability is required
 */
export type GetYourGuideActivateRequestHeadersOctoCapabilities = string;

/**
 * The UUID of the booking
 */
export type OctoBookingCancellationRequestUuid = string;

/**
 * The UUID of the booking
 */
export type OctoExtendReservationRequestUuid = string;

/**
 * The UUID of the booking
 */
export type OctoGetBookingRequestUuid = string;

/**
 * All bookings made for a specific date
 */
export type OctoGetBookingsRequestLocalDate = string;

/**
 * Last date of a date range search
 */
export type OctoGetBookingsRequestLocalDateEnd = string;

/**
 * First date of a date range search
 */
export type OctoGetBookingsRequestLocalDateStart = string;

/**
 * The option id to filter by
 */
export type OctoGetBookingsRequestOptionId = string;

/**
 * The product id to filter by
 */
export type OctoGetBookingsRequestProductId = string;

/**
 * The reseller reference on the booking
 */
export type OctoGetBookingsRequestResellerReference = string;

/**
 * The reference provided by the supplier
 */
export type OctoGetBookingsRequestSupplierReference = string;

/**
 * The product id
 */
export type OctoGetProductRequestId = string;

/**
 * A list of the Capabilities (their IDs) initialized with your request.
 */
export type OctoRequestHeadersOctoCapabilities = string;

/**
 * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
 */
export type OctoRequestHeadersContent = string;

/**
 * ventrata/partners capability is required
 */
export type PartnersListConnectionsRequestHeadersOctoCapabilities = string;

export type PartnersListConnectionsRequestHeadersVentrataPartnerKey = string;

export type AvailabilitiesAvailabilityCheckData = {
  body: AvailabilityCheckBody;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/availability/";
};

export type AvailabilitiesAvailabilityCheckResponses = {
  /**
   * The request has succeeded.
   */
  200: Array<Availability> | AvailabilityCheckErrorResponse;
};

export type AvailabilitiesAvailabilityCheckResponse =
  AvailabilitiesAvailabilityCheckResponses[keyof AvailabilitiesAvailabilityCheckResponses];

export type AvailabilitiesAvailabilityCalendarData = {
  body: AvailabilityCalendarBody;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/availability/calendar";
};

export type AvailabilitiesAvailabilityCalendarResponses = {
  /**
   * The request has succeeded.
   */
  200: Array<OctoAvailabilityCalendar> | AvailabilityCalendarErrorResponse;
};

export type AvailabilitiesAvailabilityCalendarResponse =
  AvailabilitiesAvailabilityCalendarResponses[keyof AvailabilitiesAvailabilityCalendarResponses];

export type BookingsGetBookingsData = {
  body?: never;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: {
    /**
     * The reseller reference on the booking
     */
    resellerReference?: string;
    /**
     * The reference provided by the supplier
     */
    supplierReference?: string;
    /**
     * All bookings made for a specific date
     */
    localDate?: string;
    /**
     * First date of a date range search
     */
    localDateStart?: string;
    /**
     * Last date of a date range search
     */
    localDateEnd?: string;
    /**
     * The product id to filter by
     */
    productId?: string;
    /**
     * The option id to filter by
     */
    optionId?: string;
  };
  url: "/bookings/";
};

export type BookingsGetBookingsErrors = {
  /**
   * The server could not understand the request due to invalid syntax.
   */
  400:
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type BookingsGetBookingsError =
  BookingsGetBookingsErrors[keyof BookingsGetBookingsErrors];

export type BookingsGetBookingsResponses = {
  /**
   * The request has succeeded.
   */
  200: Array<Booking>;
};

export type BookingsGetBookingsResponse =
  BookingsGetBookingsResponses[keyof BookingsGetBookingsResponses];

export type BookingsBookingUpdateData = {
  body: BookingUpdateBody;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/bookings/";
};

export type BookingsBookingUpdateErrors = {
  /**
   * The server could not understand the request due to invalid syntax.
   */
  400:
    | OctoErrorInvalidProductId
    | OctoErrorInvalidOptionId
    | OctoErrorInvalidUnitId
    | OctoErrorInvalidAvailabilityId
    | OctoErrorInvalidBookingUuid
    | OctoErrorUnprocessableEntity
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type BookingsBookingUpdateError =
  BookingsBookingUpdateErrors[keyof BookingsBookingUpdateErrors];

export type BookingsBookingUpdateResponses = {
  /**
   * The request has succeeded.
   */
  200: Booking;
};

export type BookingsBookingUpdateResponse =
  BookingsBookingUpdateResponses[keyof BookingsBookingUpdateResponses];

export type BookingsBookingReservationData = {
  body: BookingReservationBody;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/bookings/";
};

export type BookingsBookingReservationResponses = {
  /**
   * The request has succeeded.
   */
  200: Booking | BookingReservationErrorResponse;
};

export type BookingsBookingReservationResponse =
  BookingsBookingReservationResponses[keyof BookingsBookingReservationResponses];

export type BookingsGetBookingData = {
  body?: never;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path: {
    /**
     * The UUID of the booking
     */
    uuid: string;
  };
  query?: never;
  url: "/bookings/{uuid}";
};

export type BookingsGetBookingErrors = {
  /**
   * The server could not understand the request due to invalid syntax.
   */
  400:
    | OctoErrorInvalidBookingUuid
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type BookingsGetBookingError =
  BookingsGetBookingErrors[keyof BookingsGetBookingErrors];

export type BookingsGetBookingResponses = {
  /**
   * The request has succeeded.
   */
  200: Booking;
};

export type BookingsGetBookingResponse =
  BookingsGetBookingResponses[keyof BookingsGetBookingResponses];

export type BookingsBookingCancellationData = {
  body: BookingCancellationBody;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path: {
    /**
     * The UUID of the booking
     */
    uuid: string;
  };
  query?: never;
  url: "/bookings/{uuid}/cancel";
};

export type BookingsBookingCancellationResponses = {
  /**
   * The request has succeeded.
   */
  200: Booking | BookingCancellationErrorResponse;
};

export type BookingsBookingCancellationResponse =
  BookingsBookingCancellationResponses[keyof BookingsBookingCancellationResponses];

export type BookingsBookingConfirmationData = {
  body: BookingConfirmationBody;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path: {
    /**
     * The UUID of the booking
     */
    uuid: string;
  };
  query?: never;
  url: "/bookings/{uuid}/confirm";
};

export type BookingsBookingConfirmationResponses = {
  /**
   * The request has succeeded.
   */
  200: Booking | BookingConfirmationErrorResponse;
};

export type BookingsBookingConfirmationResponse =
  BookingsBookingConfirmationResponses[keyof BookingsBookingConfirmationResponses];

export type BookingsExtendReservationData = {
  body: ExtendReservationBody;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path: {
    /**
     * The UUID of the booking
     */
    uuid: string;
  };
  query?: never;
  url: "/bookings/{uuid}/extend";
};

export type BookingsExtendReservationResponses = {
  /**
   * The request has succeeded.
   */
  200: Booking | ExtendReservationErrorResponse;
};

export type BookingsExtendReservationResponse =
  BookingsExtendReservationResponses[keyof BookingsExtendReservationResponses];

export type ProductsGetProductsData = {
  body?: never;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/products/";
};

export type ProductsGetProductsErrors = {
  /**
   * The server could not understand the request due to invalid syntax.
   */
  400:
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type ProductsGetProductsError =
  ProductsGetProductsErrors[keyof ProductsGetProductsErrors];

export type ProductsGetProductsResponses = {
  /**
   * The request has succeeded.
   */
  200: Array<Product>;
};

export type ProductsGetProductsResponse =
  ProductsGetProductsResponses[keyof ProductsGetProductsResponses];

export type ProductsGetProductData = {
  body?: never;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path: {
    /**
     * The product id
     */
    id: string;
  };
  query?: never;
  url: "/products/{id}";
};

export type ProductsGetProductErrors = {
  /**
   * The server could not understand the request due to invalid syntax.
   */
  400:
    | OctoErrorInvalidProductId
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type ProductsGetProductError =
  ProductsGetProductErrors[keyof ProductsGetProductErrors];

export type ProductsGetProductResponses = {
  /**
   * The request has succeeded.
   */
  200: Product;
};

export type ProductsGetProductResponse =
  ProductsGetProductResponses[keyof ProductsGetProductResponses];

export type SuppliersGetData = {
  body?: never;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/supplier/";
};

export type SuppliersGetErrors = {
  /**
   * The server could not understand the request due to invalid syntax.
   */
  400:
    | OctoErrorUnauthorized
    | OctoErrorInternalServerError
    | OctoErrorForbidden;
};

export type SuppliersGetError = SuppliersGetErrors[keyof SuppliersGetErrors];

export type SuppliersGetResponses = {
  /**
   * The request has succeeded.
   */
  200: Supplier;
};

export type SuppliersGetResponse =
  SuppliersGetResponses[keyof SuppliersGetResponses];

export type GetYourGuidePostData = {
  body: GetYourGuideActivateBody;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request. ventrata/getyourguide capability is required
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/ventrata/getyourguide/activate";
};

export type GetYourGuidePostResponses = {
  /**
   * The request has succeeded.
   */
  200: GetYourGuideConnection;
};

export type GetYourGuidePostResponse =
  GetYourGuidePostResponses[keyof GetYourGuidePostResponses];

export type PartnersGetData = {
  body?: never;
  headers: {
    /**
     * ventrata/partners capability is required
     */
    "Octo-Capabilities": string;
    "Ventrata-Partner-Key": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/ventrata/partners/suppliers_connections";
};

export type PartnersGetResponses = {
  /**
   * The request has succeeded.
   */
  200: Array<PartnersListConnection>;
};

export type PartnersGetResponse =
  PartnersGetResponses[keyof PartnersGetResponses];

export type WhoIAmSectionGetData = {
  body?: never;
  headers: {
    /**
     * A list of the Capabilities (their IDs) initialized with your request.
     */
    "Octo-Capabilities": string;
    /**
     * This optional request header allows to specify preferred languages for content in the response. A language code that specifies the language of the product content. This code must conform to the BCP 47 standard, following RFC 5646 and RFC 4647 specifications for language tags. Examples include en-US for American English, fr-FR for French (France), and es-ES for Spanish (Spain). This header supports a comma-separated list of language tags with optional quality values (q) to indicate priority, such as en-US, fr-CA;q=0.8, fr;q=0.7, which prioritizes U.S. English, followed by Canadian French, and general French. This header is defined in the HTTP/1.1 specification (RFC 7231) and is commonly used for internationalized websites and services to enhance user experience. For more details, visit MDN Web Docs: Accept-Language - HTTP | MDN. Note this only determines preference and does not guarantee location has content available in the desired language.
     */
    "Accept-Language"?: string;
  };
  path?: never;
  query?: never;
  url: "/whoami";
};

export type WhoIAmSectionGetResponses = {
  /**
   * The request has succeeded.
   */
  200: WhoIAm;
};

export type WhoIAmSectionGetResponse =
  WhoIAmSectionGetResponses[keyof WhoIAmSectionGetResponses];

export type ClientOptions = {
  baseUrl: "https://api.ventrata.com/octo" | (string & {});
};
